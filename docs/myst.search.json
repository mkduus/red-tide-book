{"version":"1","records":[{"hierarchy":{"lvl1":"Data Integration for Southwest Florida"},"type":"lvl1","url":"/data-swfl-combined","position":0},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida"},"content":"","type":"content","url":"/data-swfl-combined","position":1},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"1. Discharge Monitoring at S.R.-79 on the Caloosahatchee River"},"type":"lvl2","url":"/data-swfl-combined#id-1-discharge-monitoring-at-s-r-79-on-the-caloosahatchee-river","position":2},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"1. Discharge Monitoring at S.R.-79 on the Caloosahatchee River"},"content":"\n\n","type":"content","url":"/data-swfl-combined#id-1-discharge-monitoring-at-s-r-79-on-the-caloosahatchee-river","position":3},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"1.1 Selecting Discharge Station on Caloosahatchee River","lvl2":"1. Discharge Monitoring at S.R.-79 on the Caloosahatchee River"},"type":"lvl3","url":"/data-swfl-combined#id-1-1-selecting-discharge-station-on-caloosahatchee-river","position":4},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"1.1 Selecting Discharge Station on Caloosahatchee River","lvl2":"1. Discharge Monitoring at S.R.-79 on the Caloosahatchee River"},"content":"\n\nThe USGS site number 02292900 corresponds to the streamflow monitoring station at the Caloosahatchee River at S.R.-79 near Olga, Florida. This station, also known as the Franklin Lock and Dam (S-79), has been operational since 1966 and is a key point for monitoring freshwater flow into the Caloosahatchee Estuary.\n\nThis site is managed by the U.S. Geological Survey (USGS) and provides real-time and historical data on streamflow, which is crucial for water resource management, ecological studies, and flood forecasting.\n\nUSGS site data: \n\nhttps://​waterdata​.usgs​.gov​/nwis​/inventory​?site​_no​=​02292900\n\nimport pandas as pd\nimport os\nimport pandas as pd\nimport requests\nimport zipfile\nfrom io import BytesIO\nimport shutil\n\ndf_dis = pd.read_csv('USGS Data Science Project.csv')\ndf_dis\n\n\n\ndf_dis.Date = pd.to_datetime(df_dis.Date)\ndf_dis.Date.dtypes\n\n\n\ncolumns = ['Source', 'Site Number', 'Date', 'Discharge']\ndf_dis = df_dis[columns]\ndf_dis\n\n\n\n# Data cleaned\ndf_dis_clean = df_dis.dropna()\n\nparameters = ['Discharge']\nunits = ['cfs']\n\nmetadata = {\n    'Discharge': {'Unit': 'cfs'}\n}\n\nsummary_data = []\n\nfor column in df_dis.columns:\n    if column not in metadata:\n        continue\n\n    col_data = df_dis[column].dropna()\n    stats = {\n        'Parameter': column,\n        'Unit': metadata[column]['Unit'],\n        'Min': round(col_data.min(), 2),\n        'Mean': round(col_data.mean(), 2),\n        'Median': round(col_data.median(), 2),\n        'Max': round(col_data.max(), 2)\n    }\n    summary_data.append(stats)\n\ndf_dis_summary = pd.DataFrame(summary_data)\ndisplay(df_dis_summary)\n\n\n\n","type":"content","url":"/data-swfl-combined#id-1-1-selecting-discharge-station-on-caloosahatchee-river","position":5},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"1.2 Caloosahatchee River Discharge","lvl2":"1. Discharge Monitoring at S.R.-79 on the Caloosahatchee River"},"type":"lvl3","url":"/data-swfl-combined#id-1-2-caloosahatchee-river-discharge","position":6},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"1.2 Caloosahatchee River Discharge","lvl2":"1. Discharge Monitoring at S.R.-79 on the Caloosahatchee River"},"content":"\n\nThis section processes discharge data from the Caloosahatchee River at the S-79 structure, obtained from the USGS. The data is filtered to retain daily mean discharge values, and timestamps are converted to datetime format for alignment with other environmental datasets. The section ensures the discharge values are numeric and drops any rows with missing data.\n\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Line plot of discharge\ndf_dis[['Discharge']].plot(\n    color=['blue'],\n    linewidth=1,\n    xlabel='Date',\n    ylabel='Discharge_Dis [cfs]',\n    figsize=(16, 7),\n    title='Caloosahatchee River Discharge',\n    grid=False,\n    legend=True,\n    style=['-'],\n    alpha=0.8,\n    rot=0,\n    fontsize=12,\n);\n\n\n\nmax_discharge_dis = df_dis['Discharge'].max()\nprint(max_discharge_dis)\n\n\n\navg_discharge_dis = df_dis['Discharge'].mean()\nprint(avg_discharge_dis)\n\n\n\n","type":"content","url":"/data-swfl-combined#id-1-2-caloosahatchee-river-discharge","position":7},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"1.3 Creating a Continuous Discharge Record","lvl2":"1. Discharge Monitoring at S.R.-79 on the Caloosahatchee River"},"type":"lvl3","url":"/data-swfl-combined#id-1-3-creating-a-continuous-discharge-record","position":8},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"1.3 Creating a Continuous Discharge Record","lvl2":"1. Discharge Monitoring at S.R.-79 on the Caloosahatchee River"},"content":"\n\nThis section addresses gaps in the Caloosahatchee River discharge dataset by applying interpolation and filling techniques. Missing discharge values are first replaced with NaNs, then interpolated linearly to estimate intermediate values. Any remaining missing values at the start or end of the series are filled using forward and backward fill methods. The cleaned and gap-filled dataset is then visualized in a time series plot spanning from 1993 to 2025, showing the long-term variability in daily discharge rates. This step ensures a continuous discharge record for use in later modeling and analysis.\n\n# Replace 0s with NaN in 'Discharge' column\ndf_dis.loc[:, 'Discharge'] = df_dis['Discharge'].replace(0, pd.NA)\n\n# Interpolate missing values linearly\ndf_dis.loc[:, 'Discharge'] = df_dis['Discharge'].interpolate(method='linear')\n\n# Fill remaining NaNs at the start/end using forward/backward fill\ndf_dis.loc[:, 'Discharge'] = df_dis['Discharge'].ffill().bfill()\n\n\n\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Ensure 'Date' is datetime\ndf_dis['Date'] = pd.to_datetime(df_dis['Date'])\n\n# Create plot\nplt.figure(num=18, figsize=(16, 7))\nplt.plot(df_dis['Date'], df_dis['Discharge'], color='blue', linewidth=1, linestyle='-', alpha=0.8, label='Discharge')\n\n# Format x-axis\nplt.gca().xaxis.set_major_locator(mdates.YearLocator())\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))\nplt.xlim(df_dis['Date'].min(), df_dis['Date'].max())\n\n# Add horizontal line at 0\nplt.axhline(y=0, color='black', linestyle='--', linewidth=1)\n\n# Labels and formatting\nplt.xlabel('Date', fontsize=12)\nplt.ylabel('Discharge [cfs]', fontsize=12)\nplt.title('Caloosahatchee River Discharge', fontsize=20)\nplt.legend()\nplt.grid(True)\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n","type":"content","url":"/data-swfl-combined#id-1-3-creating-a-continuous-discharge-record","position":9},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"1.4 Discharge With Hurricane Season Noted","lvl2":"1. Discharge Monitoring at S.R.-79 on the Caloosahatchee River"},"type":"lvl3","url":"/data-swfl-combined#id-1-4-discharge-with-hurricane-season-noted","position":10},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"1.4 Discharge With Hurricane Season Noted","lvl2":"1. Discharge Monitoring at S.R.-79 on the Caloosahatchee River"},"content":"\n\nThis section enhances the Caloosahatchee River discharge time series by visually marking the Atlantic hurricane season (June 1 to November 30) for each year in the dataset. Using a loop, shaded bands are dynamically added to the plot for every hurricane season between 1993 and 2025. This contextual overlay allows for a clearer visual association between periods of heightened tropical activity and observed discharge spikes. By highlighting these seasonal windows, the plot provides insight into how discharge patterns may be influenced by rainfall and runoff associated with hurricanes and tropical storms, which are relevant for nutrient loading and potential HAB triggers.\n\nfrom datetime import datetime\n\nplt.figure(num=19, figsize=(16, 7))\nplt.plot(df_dis['Date'], df_dis['Discharge'], color='blue', linewidth=1, linestyle='-', alpha=0.8, label='Discharge')\n\nplt.gca().xaxis.set_major_locator(mdates.YearLocator())\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))\nplt.xlim(df_dis['Date'].min(), df_dis['Date'].max())\n\n# Highlight hurricane season\nyears = df_dis['Date'].dt.year.unique()\nfor year in years:\n    start = pd.Timestamp(f\"{year}-06-01\")\n    end = pd.Timestamp(f\"{year}-11-30\")\n    plt.axvspan(start, end, color='orange', alpha=0.125, label='Hurricane Season' if year == years[0] else \"\")\n\nplt.xlabel('Date', fontsize=12)\nplt.ylabel('Discharge [cfs]', fontsize=12)\nplt.title('Caloosahatchee River Discharge with Hurricane Season Indicated', fontsize=16)\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\nplt.figure(num=20, figsize=(16, 7))\nplt.plot(df_dis['Date'], df_dis['Discharge'], color='blue', linewidth=1, linestyle='-', alpha=0.8, label='Discharge')\n\nplt.gca().xaxis.set_major_locator(mdates.YearLocator())\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))\nplt.xlim(df_dis['Date'].min(), df_dis['Date'].max())\n\n# Shade hurricane season for each year\nfor year in df_dis['Date'].dt.year.unique():\n    start = pd.Timestamp(f\"{year}-06-01\")\n    end = pd.Timestamp(f\"{year}-11-30\")\n    plt.axvspan(start, end, color='orange', alpha=0.1, label='Hurricane Season' if year == df_dis['Date'].dt.year.unique()[0] else \"\")\n\nplt.xlabel('Date', fontsize=12)\nplt.ylabel('Discharge [cfs]', fontsize=12)\nplt.title('Caloosahatchee River Discharge with Hurricane Season Indicated', fontsize=12)\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-1-4-discharge-with-hurricane-season-noted","position":11},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"type":"lvl2","url":"/data-swfl-combined#id-2-nutrient-data-for-the-caloosahatchee-river-tn-and-tp-monitoring","position":12},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"content":"\n\nThe Total Nitrogen (TN) and Total Phosphorus (TP) data for both the upper and lower Caloosahatchee River were obtained from Florida’s STORET repository, a state-managed version of the EPA’s national water quality database. These records include monitoring results from agencies like the Florida Department of Environmental Protection and Lee County’s Environmental Laboratory.\n\nThe dataset provides time-stamped, geolocated measurements of nutrient concentrations, which are essential for assessing eutrophication risk and forecasting red tide conditions driven by land-based nutrient runoff.\n\nWater Atlas data site: \n\nhttps://​chnep​.wateratlas​.usf​.edu/\n\n","type":"content","url":"/data-swfl-combined#id-2-nutrient-data-for-the-caloosahatchee-river-tn-and-tp-monitoring","position":13},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.1 Nutrient Data: Upper Caloosahatchee (Olga, FL)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"type":"lvl3","url":"/data-swfl-combined#id-2-1-nutrient-data-upper-caloosahatchee-olga-fl","position":14},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.1 Nutrient Data: Upper Caloosahatchee (Olga, FL)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"content":"\n\nThis section loads nutrient monitoring data from the upper Caloosahatchee River at the S.R. 79 (Olga) station and prepares it for analysis. The dataset is filtered to extract relevant nutrient parameters and converted to datetime format for alignment with other variables.\n\nimport pandas as pd\n\n# Load the Caloosahatchee nutrient data\nnutrient_data = pd.read_csv(\"TN_TP_Caloosa.csv\")\n\n# Preview the dataset\nnutrient_data.head()\n\n\n\n# Convert sample date to datetime\nnutrient_data['SampleDate'] = pd.to_datetime(nutrient_data['SampleDate'], errors='coerce')\n\n# Filter by nutrient type for Upper Caloosahatchee\ntp_data_upper = nutrient_data[nutrient_data['Parameter'] == 'TP_mg/l']\ntn_data_upper = nutrient_data[nutrient_data['Parameter'] == 'TN_mg/l']\n\nnutrient_data\n\n\n\n","type":"content","url":"/data-swfl-combined#id-2-1-nutrient-data-upper-caloosahatchee-olga-fl","position":15},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.2 Total Phosphorous Over Time (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"type":"lvl3","url":"/data-swfl-combined#id-2-2-total-phosphorous-over-time-outliers-removed","position":16},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.2 Total Phosphorous Over Time (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"content":"\n\nThis section filters and visualizes TP data at the Olga station, removing outliers using the interquartile range (IQR) method. After converting values to numeric format and dropping any missing entries, the code calculates the lower and upper bounds for acceptable values and filters out extreme outliers. The cleaned data is then plotted as a time series.\n\nThe resulting chart shows TP concentrations over time from approximately 1999 to 2024. The data appears sparse before 2015 but becomes more densely sampled in recent years. Most values cluster between 0.05 and 0.15 mg/L, with a slight downward trend and reduced variability over time—possibly reflecting changes in land use, management practices, or sampling consistency.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# --- 1. Load and Prepare Nutrient Data (Upper Caloosahatchee - Olga, FL) ---\nnutrient_data = pd.read_csv(\"TN_TP_Caloosa.csv\")  # or your local path\nnutrient_data['SampleDate'] = pd.to_datetime(nutrient_data['SampleDate'], errors='coerce')\n\n# Filter by correct nutrient labels (check spelling)\ntp_data_upper = nutrient_data[nutrient_data['Parameter'] == 'TP_mgl']\ntn_data_upper = nutrient_data[nutrient_data['Parameter'] == 'TN_mgl']\n\n# --- 2. Clean and Filter TP Data ---\ntp_data_upper['Result_Value'] = pd.to_numeric(tp_data_upper['Result_Value'], errors='coerce')\ntp_clean_upper = tp_data_upper.dropna(subset=['Result_Value'])\n\n# Detect and filter out outliers using IQR\nQ1_tp = tp_clean_upper['Result_Value'].quantile(0.25)\nQ3_tp = tp_clean_upper['Result_Value'].quantile(0.75)\nIQR_tp = Q3_tp - Q1_tp\n\ntp_filtered_upper = tp_clean_upper[\n    (tp_clean_upper['Result_Value'] >= Q1_tp - 1.5 * IQR_tp) &\n    (tp_clean_upper['Result_Value'] <= Q3_tp + 1.5 * IQR_tp)\n]\n\n# --- 3. Plot Filtered TP Data ---\nplt.figure(figsize=(10, 4))\nplt.scatter(tp_filtered_upper['SampleDate'], tp_filtered_upper['Result_Value'],\n            alpha=0.5, color='blue', label='Total Phosphorus (Filtered)')\nplt.title('Total Phosphorus (TP) Concentration Over Time (Outliers Removed) - Upper Caloosahatchee')\nplt.xlabel('Sample Date')\nplt.ylabel('TP (mg/L)')\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n","type":"content","url":"/data-swfl-combined#id-2-2-total-phosphorous-over-time-outliers-removed","position":17},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.3 Total Nitrogen Over Time (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"type":"lvl3","url":"/data-swfl-combined#id-2-3-total-nitrogen-over-time-outliers-removed","position":18},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.3 Total Nitrogen Over Time (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"content":"\n\nThis section processes TN data at the Olga station by converting result values to numeric format, dropping missing entries, and removing statistical outliers using the interquartile range (IQR) method. The filtered dataset is then plotted to visualize trends over time.\n\nThe resulting chart displays TN concentrations from the late 1990s through 2024. Like the phosphorus dataset, early records are sparse, with sampling density increasing significantly after 2015. Most values range between 1.0 and 1.6 mg/L. There is no obvious long-term trend, but a tighter clustering of values in more recent years may reflect improved monitoring consistency or reduced variability in nutrient inputs.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Convert TN values to float\ntn_data_upper['Result_Value'] = pd.to_numeric(tn_data_upper['Result_Value'], errors='coerce')\n\n# Remove NaNs\ntn_clean_upper = tn_data_upper.dropna(subset=['Result_Value'])\n\n# Detect outliers using IQR\nQ1 = tn_clean_upper['Result_Value'].quantile(0.25)\nQ3 = tn_clean_upper['Result_Value'].quantile(0.75)\nIQR = Q3 - Q1\n\n# Filter out outliers\ntn_filtered_upper = tn_clean_upper[\n    (tn_clean_upper['Result_Value'] >= Q1 - 1.5 * IQR) &\n    (tn_clean_upper['Result_Value'] <= Q3 + 1.5 * IQR)\n]\n\n# Plot filtered TN data\nplt.figure(figsize=(10, 4))\nplt.scatter(tn_filtered_upper['SampleDate'], tn_filtered_upper['Result_Value'],\n            alpha=0.5, color='green', label='Total Nitrogen (Filtered)')\nplt.title('Total Nitrogen (TN) Concentration Over Time (Outliers Removed) - Upper Caloosahatchee')\nplt.xlabel('Sample Date')\nplt.ylabel('TN (mg/L)')\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n","type":"content","url":"/data-swfl-combined#id-2-3-total-nitrogen-over-time-outliers-removed","position":19},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.4 Combined TN and TP Trendline, Olga, FL (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"type":"lvl3","url":"/data-swfl-combined#id-2-4-combined-tn-and-tp-trendline-olga-fl-outliers-removed","position":20},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.4 Combined TN and TP Trendline, Olga, FL (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"content":"\n\nThis section aggregates the cleaned nutrient data into monthly averages to reveal long-term trends in nitrogen and phosphorus concentrations at the Olga monitoring site. Missing months are interpolated to produce continuous time series for both parameters. The data is visualized in two synchronized subplots sharing the same time axis.\n\nThe top plot shows a monthly trend of TN concentrations, which fluctuate but show a general decline in variability and magnitude over the past two decades. The bottom plot illustrates the TP trend, which is more seasonally variable and features sharper peaks, especially in the mid-2000s and late 2010s. Together, these plots highlight nutrient dynamics over time and provide context for understanding their potential role in fueling algal blooms downstream.\n\n# Resample monthly and interpolate missing months\ntn_monthly_upper = tn_filtered_upper.set_index('SampleDate')['Result_Value'].resample('M').mean().asfreq('M').interpolate()\ntp_monthly_upper = tp_filtered_upper.set_index('SampleDate')['Result_Value'].resample('M').mean().asfreq('M').interpolate()\n\n\n\nimport matplotlib.pyplot as plt\n\n# Plot TN and TP on two subplots (shared x-axis)\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 8), sharex=True)\n\n# Plot TN\nax1.plot(tn_monthly_upper.index, tn_monthly_upper.values, color='green', label='Total Nitrogen (TN)', linewidth=2)\nax1.set_ylabel('TN (mg/L)')\nax1.set_title('Monthly Trend of Total Nitrogen (Upper Caloosahatchee)')\nax1.grid(True)\nax1.legend()\n\n# Plot TP\nax2.plot(tp_monthly_upper.index, tp_monthly_upper.values, color='blue', label='Total Phosphorus (TP)', linewidth=2)\nax2.set_ylabel('TP (mg/L)')\nax2.set_title('Monthly Trend of Total Phosphorus (Upper Caloosahatchee)')\nax2.set_xlabel('Date')\nax2.grid(True)\nax2.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-2-4-combined-tn-and-tp-trendline-olga-fl-outliers-removed","position":21},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.5 Nutrient Data: Lower Caloosahatchee (Fort Myers, FL)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"type":"lvl3","url":"/data-swfl-combined#id-2-5-nutrient-data-lower-caloosahatchee-fort-myers-fl","position":22},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.5 Nutrient Data: Lower Caloosahatchee (Fort Myers, FL)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"content":"\n\nThis section loads nutrient monitoring data for the tidal portion of the Caloosahatchee River near Fort Myers. As with the upper river data, this dataset includes TN and TP measurements and is used to complement the upstream records. Including this site allows the analysis to capture nutrient movement downstream, offering a fuller picture of how concentrations evolve as water flows from the Olga station toward the Gulf of Mexico.\n\nimport pandas as pd\n\n# Load the Caloosahatchee nutrient data\nnutrient_tidal = pd.read_csv(\"TN_TP_Tidal_Caloosa.csv\")\n\n# Preview the dataset\nnutrient_tidal.head()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-2-5-nutrient-data-lower-caloosahatchee-fort-myers-fl","position":23},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.6 Total Phosphorous Over Time (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"type":"lvl3","url":"/data-swfl-combined#id-2-6-total-phosphorous-over-time-outliers-removed","position":24},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.6 Total Phosphorous Over Time (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"content":"\n\nThis section repeats the methods of Section 2.2 for the tidal Caloosahatchee River.\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\n# Strip any trailing/leading whitespace from column names\nnutrient_tidal.columns = nutrient_tidal.columns.str.strip()\n\n# --- Convert TP values to numeric ---\ntp_data_tidal = nutrient_tidal[nutrient_tidal['Parameter'] == 'TP_mgl'].copy()\ntp_data_tidal['Result_Value'] = pd.to_numeric(tp_data_tidal['Result_Value'], errors='coerce')\ntp_data_tidal['SampleDate'] = pd.to_datetime(tp_data_tidal['SampleDate'], errors='coerce')\n\n# --- Remove NaNs ---\ntp_clean_tidal = tp_data_tidal.dropna(subset=['Result_Value'])\n\n# --- Detect outliers using IQR ---\nQ1_tp = tp_clean_tidal['Result_Value'].quantile(0.25)\nQ3_tp = tp_clean_tidal['Result_Value'].quantile(0.75)\nIQR_tp = Q3_tp - Q1_tp\n\n# --- Filter out outliers ---\ntp_filtered_tidal = tp_clean_tidal[\n    (tp_clean_tidal['Result_Value'] >= Q1_tp - 1.5 * IQR_tp) &\n    (tp_clean_tidal['Result_Value'] <= Q3_tp + 1.5 * IQR_tp)\n]\n\n# --- Plot Filtered TP data ---\nplt.figure(figsize=(10, 4))\nplt.scatter(tp_filtered_tidal['SampleDate'], tp_filtered_tidal['Result_Value'], \n            alpha=0.5, color='blue', label='Total Phosphorus (Filtered)')\nplt.title('Total Phosphorus (TP) Concentration Over Time (Outliers Removed) - Tidal Caloosahatchee')\nplt.xlabel('Sample Date')\nplt.ylabel('TP (mg/L)')\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-2-6-total-phosphorous-over-time-outliers-removed","position":25},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.7 Total Nitrogen Over Time (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"type":"lvl3","url":"/data-swfl-combined#id-2-7-total-nitrogen-over-time-outliers-removed","position":26},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.7 Total Nitrogen Over Time (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"content":"\n\nThis section repeats the methods of Section 2.3 for the tidal Caloosahatchee River.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Filter and convert TN values\ntn_data_tidal = nutrient_tidal[nutrient_tidal['Parameter'] == 'TN_mgl'].copy()\ntn_data_tidal['Result_Value'] = pd.to_numeric(tn_data_tidal['Result_Value'], errors='coerce')\ntn_data_tidal['SampleDate'] = pd.to_datetime(tn_data_tidal['SampleDate'], errors='coerce')\n\n# Remove NaNs\ntn_clean_tidal = tn_data_tidal.dropna(subset=['Result_Value'])\n\n# Detect outliers using IQR\nQ1_tn_tidal = tn_clean_tidal['Result_Value'].quantile(0.25)\nQ3_tn_tidal = tn_clean_tidal['Result_Value'].quantile(0.75)\nIQR_tn_tidal = Q3_tn_tidal - Q1_tn_tidal\n\n# Filter out outliers\ntn_filtered_tidal = tn_clean_tidal[\n    (tn_clean_tidal['Result_Value'] >= Q1_tn_tidal - 1.5 * IQR_tn_tidal) &\n    (tn_clean_tidal['Result_Value'] <= Q3_tn_tidal + 1.5 * IQR_tn_tidal)\n]\n\n# Plot Filtered TN data\nplt.figure(figsize=(10, 4))\nplt.scatter(tn_filtered_tidal['SampleDate'], tn_filtered_tidal['Result_Value'], \n            alpha=0.5, color='green', label='Total Nitrogen (Filtered)')\nplt.title('Total Nitrogen (TN) Concentration Over Time (Outliers Removed) - Tidal Caloosahatchee')\nplt.xlabel('Sample Date')\nplt.ylabel('TN (mg/L)')\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-2-7-total-nitrogen-over-time-outliers-removed","position":27},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.8 Combined TN and TP Trendline, Fort Myers (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"type":"lvl3","url":"/data-swfl-combined#id-2-8-combined-tn-and-tp-trendline-fort-myers-outliers-removed","position":28},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.8 Combined TN and TP Trendline, Fort Myers (Outliers Removed)","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"content":"\n\nThis section repeats the methods of Section 2.4 for the tidal Caloosahatchee River.\n\n# --- Resample monthly and interpolate missing months for Tidal Caloosahatchee ---\ntn_monthly_tidal = tn_filtered_tidal.set_index('SampleDate')['Result_Value'] \\\n    .resample('M').mean().asfreq('M').interpolate()\n\ntp_monthly_tidal = tp_filtered_tidal.set_index('SampleDate')['Result_Value'] \\\n    .resample('M').mean().asfreq('M').interpolate()\n\n\n\nimport matplotlib.pyplot as plt\n\n# --- Plot TN and TP trends for Tidal Caloosahatchee in stacked subplots ---\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 8), sharex=True)\n\n# TN plot\nax1.plot(tn_monthly_tidal.index, tn_monthly_tidal.values, color='green', linewidth=2, label='Total Nitrogen (TN)')\nax1.set_ylabel('TN (mg/L)')\nax1.set_title('Monthly Trend of Total Nitrogen (Tidal Caloosahatchee)')\nax1.grid(True)\nax1.legend()\n\n# TP plot\nax2.plot(tp_monthly_tidal.index, tp_monthly_tidal.values, color='blue', linewidth=2, label='Total Phosphorus (TP)')\nax2.set_ylabel('TP (mg/L)')\nax2.set_title('Monthly Trend of Total Phosphorus (Tidal Caloosahatchee)')\nax2.set_xlabel('Date')\nax2.grid(True)\nax2.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-2-8-combined-tn-and-tp-trendline-fort-myers-outliers-removed","position":29},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.9 Combined and Averaged Time Series for the Caloosahatchee River","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"type":"lvl3","url":"/data-swfl-combined#id-2-9-combined-and-averaged-time-series-for-the-caloosahatchee-river","position":30},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"2.9 Combined and Averaged Time Series for the Caloosahatchee River","lvl2":"2. Nutrient Data for the Caloosahatchee River: TN and TP Monitoring"},"content":"\n\nTo better support the machine learning analysis, we combined the TN and TP data from both the upper (Olga) and lower (Fort Myers) Caloosahatchee River sites.\n\nThis was done by averaging the monthly resampled and interpolated TN and TP concentrations from both locations. The result is a single, unified timeseries for TN and TP that represents the average nutrient concentrations flowing out of the Caloosahatchee River.\n\nThis provides a more comprehensive and simplified input for evaluating how nutrient levels may correlate with harmful algal bloom (HAB) activity in downstream coastal waters.\n\n# --- Combine and average monthly TN and TP data from upper and tidal Caloosahatchee ---\n\n# First align the date indices to ensure no mismatch\ntn_monthly_upper = tn_monthly_upper.sort_index()\ntp_monthly_upper = tp_monthly_upper.sort_index()\ntn_monthly_tidal = tn_monthly_tidal.sort_index()\ntp_monthly_tidal = tp_monthly_tidal.sort_index()\n\n# Align on same monthly date index (outer join, then take average where both exist)\ncombined_tn = pd.concat([tn_monthly_upper, tn_monthly_tidal], axis=1)\ncombined_tp = pd.concat([tp_monthly_upper, tp_monthly_tidal], axis=1)\n\n# Rename columns for clarity\ncombined_tn.columns = ['TN_Upper', 'TN_Tidal']\ncombined_tp.columns = ['TP_Upper', 'TP_Tidal']\n\n# Take the average (will ignore NaN if one side is missing)\ncombined_tn['TN_Avg'] = combined_tn.mean(axis=1)\ncombined_tp['TP_Avg'] = combined_tp.mean(axis=1)\n\n# Extract final single-column Series for modeling\ntn_avg = combined_tn['TN_Avg']\ntp_avg = combined_tp['TP_Avg']\n\n\n\nimport matplotlib.pyplot as plt\n\n# Create side-by-side subplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 8), sharex=True)\n\n# Plot TN\nax1.plot(tn_avg.index, tn_avg.values, color='green', linewidth=2, label='Avg Total Nitrogen (TN)')\nax1.set_ylabel('TN (mg/L)')\nax1.set_title('Monthly Average Total Nitrogen from Caloosahatchee River')\nax1.grid(True)\nax1.legend()\n\n# Plot TP\nax2.plot(tp_avg.index, tp_avg.values, color='blue', linewidth=2, label='Avg Total Phosphorus (TP)')\nax2.set_ylabel('TP (mg/L)')\nax2.set_title('Monthly Average Total Phosphorus from Caloosahatchee River')\nax2.set_xlabel('Date')\nax2.grid(True)\nax2.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-2-9-combined-and-averaged-time-series-for-the-caloosahatchee-river","position":31},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"3. Resampling Caloosahatchee TN and TP to Match Peace River"},"type":"lvl2","url":"/data-swfl-combined#id-3-resampling-caloosahatchee-tn-and-tp-to-match-peace-river","position":32},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"3. Resampling Caloosahatchee TN and TP to Match Peace River"},"content":"\n\nThere are discrepancies between the Peace River and Caloosahatchee River TN and TP datasets. Namely, the Peace River TN and TP is sampled daily and is measured in ugl, while the Caloosahatchee River TN and TP is averaged monthly and measured in mgl. The following code updates the Caloosahatchee River data to match the Peace River data in preparation for creating a feature file to be used in the Peace River code.\n\nimport pandas as pd\n\n# --- Load upper and tidal nutrient data ---\ndf_upper = pd.read_csv(\"TN_TP_Caloosa.csv\")\ndf_tidal = pd.read_csv(\"TN_TP_Tidal_Caloosa.csv\")\n\ndef prepare_daily_nutrient_series(df, tn_code='TN_mgl', tp_code='TP_mgl'):\n    df = df.copy()\n\n    # Convert to datetime\n    df['SampleDate'] = pd.to_datetime(df['SampleDate'])\n\n    # Filter for TN and TP\n    df_tn = df[df['Parameter'] == tn_code][['SampleDate', 'Result_Value']].copy()\n    df_tp = df[df['Parameter'] == tp_code][['SampleDate', 'Result_Value']].copy()\n\n    # Convert mg/L to µg/L\n    df_tn['Result_Value'] *= 1000\n    df_tp['Result_Value'] *= 1000\n\n    # Group by date and average if more than one reading per day\n    tn_daily = df_tn.groupby('SampleDate').mean()\n    tp_daily = df_tp.groupby('SampleDate').mean()\n\n    # Reindex to full date range and interpolate missing days\n    full_range = pd.date_range(start=df['SampleDate'].min(), end=df['SampleDate'].max(), freq='D')\n    tn_daily = tn_daily.reindex(full_range).interpolate()\n    tp_daily = tp_daily.reindex(full_range).interpolate()\n\n    # Rename columns for clarity\n    tn_daily.columns = ['TN']\n    tp_daily.columns = ['TP']\n\n    return tn_daily, tp_daily\n\n# --- Prepare upper and tidal separately ---\ntn_upper, tp_upper = prepare_daily_nutrient_series(df_upper)\ntn_tidal, tp_tidal = prepare_daily_nutrient_series(df_tidal)\n\n# --- Combine and average across stations ---\ncombined_tn = pd.concat([tn_upper, tn_tidal], axis=1)\ncombined_tp = pd.concat([tp_upper, tp_tidal], axis=1)\n\ncombined_tn.columns = ['TN_Upper', 'TN_Tidal']\ncombined_tp.columns = ['TP_Upper', 'TP_Tidal']\n\n# Take the daily average (ignores NaN if only one site sampled)\ncombined_tn['TN_Avg'] = combined_tn.mean(axis=1)\ncombined_tp['TP_Avg'] = combined_tp.mean(axis=1)\n\n# Extract final time series\ntn_avg = combined_tn[['TN_Avg']]\ntp_avg = combined_tp[['TP_Avg']]\n\n# Optional: merge into one DataFrame\ndf_nutrients_daily = pd.concat([tn_avg, tp_avg], axis=1)\n\n# View result\nprint(df_nutrients_daily.head())\n\n\n\n\n","type":"content","url":"/data-swfl-combined#id-3-resampling-caloosahatchee-tn-and-tp-to-match-peace-river","position":33},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"4. Combine Discharge and TN/TP Data Frames"},"type":"lvl2","url":"/data-swfl-combined#id-4-combine-discharge-and-tn-tp-data-frames","position":34},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"4. Combine Discharge and TN/TP Data Frames"},"content":"\n\nBelow, we combined daily-averaged discharge, total nitrogen, and total phosphorus data into a unified feature set. Discharge was downsampled to match the monthly resolution of the nutrient data. This dataset captures key flow and nutrient conditions from the Caloosahatchee River system and is structured to match the Peace River format for ML modeling.\n\nprint(df_dis.index)\nprint(df_nutrients_daily.index)\n\n\n\n# Convert df_dis['Date'] to datetime and set it as index\ndf_dis['Date'] = pd.to_datetime(df_dis['Date'])\ndf_dis.set_index('Date', inplace=True)\n\n# Make sure df_nutrients_daily index is also datetime (you've already done this)\ndf_nutrients_daily.index = pd.to_datetime(df_nutrients_daily.index)\n\n# Now safely concatenate based on the datetime index\ndf_combined = pd.concat([df_dis, df_nutrients_daily], axis=1, join='inner')  # only keeps overlapping dates\n\n# Drop any remaining NaNs if needed\ndf_combined.dropna(inplace=True)\n\n# Check results\nprint(df_combined.head())\n\n\n\n\n\n# Ensure Date column is present and set as datetime index for df_dis\ndf_dis = df_dis.copy()\nif df_dis.index.name == 'Date':\n    df_dis.reset_index(inplace=True)  # brings 'Date' back as a column\n\ndf_dis['Date'] = pd.to_datetime(df_dis['Date'])  # ensure datetime format\ndf_dis.set_index('Date', inplace=True)  # set as index for alignment\n\n# Ensure df_nutrients_daily index is datetime\ndf_nutrients_daily.index = pd.to_datetime(df_nutrients_daily.index)\n\n# Concatenate on aligned datetime index\ndf_combined = pd.concat([df_dis, df_nutrients_daily], axis=1, join='inner')\n\n# Rename nutrient columns to match ML features\ndf_combined.rename(columns={\n    'TN_Avg': 'caloosa_total_nitrogen',\n    'TP_Avg': 'caloosa_total_phosphorus'\n}, inplace=True)\n\n# Drop rows with missing data\ndf_combined.dropna(inplace=True)\n\n# Reset index so 'Date' becomes a column again\ndf_combined.reset_index(inplace=True)\n\n# Confirm the column is actually named 'Date'\nprint(df_combined.columns)\n\n# Save to CSV (no need to reselect columns if they're already right)\ndf_combined.to_csv('caloosa_features.csv', index=False)\n\n# View result\nprint(df_combined.head())\n\n\n\n# Reset index so 'Date' becomes a column again\ndf_combined.reset_index(inplace=True)\n\n# Rename the index column to 'Date' explicitly\ndf_combined.rename(columns={'index': 'Date'}, inplace=True)\n\n# Optional: reorder columns\ndf_combined = df_combined[['Date', 'Discharge', 'caloosa_total_nitrogen', 'caloosa_total_phosphorus']]\n\n# Save to CSV\ndf_combined.to_csv('caloosa_features.csv', index=False)\n\n# Preview\nprint(df_combined.head())\n\n\n\n# Rename 'Discharge' to match naming convention\ndf_combined.rename(columns={'Discharge': 'caloosa_discharge'}, inplace=True)\ndf_combined.head()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-4-combine-discharge-and-tn-tp-data-frames","position":35},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"4. Create Caloosahatchee Features File"},"type":"lvl2","url":"/data-swfl-combined#id-4-create-caloosahatchee-features-file","position":36},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"4. Create Caloosahatchee Features File"},"content":"\n\n# Restore date column for resampling\ndf_combined = pd.read_csv('caloosa_features.csv')  # Reload if needed\ndf_combined['Date'] = pd.to_datetime(df_combined['Date'])  # Ensure proper datetime type\ndf_combined.set_index('Date', inplace=True)  # Set Date as index for resampling\n# Rename 'Discharge' to match naming convention\ndf_combined.rename(columns={'Discharge': 'caloosa_discharge'}, inplace=True)\ndf_combined.head()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-4-create-caloosahatchee-features-file","position":37},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"5. Resample Caloosahatchee Data to Weekly"},"type":"lvl2","url":"/data-swfl-combined#id-5-resample-caloosahatchee-data-to-weekly","position":38},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"5. Resample Caloosahatchee Data to Weekly"},"content":"\n\nThe final data for the Peace River parameters is interpolated weekly, so we need to resample the Calooshatchee data to weekly.\n\n# Resample to weekly (Monday start) using mean for each variable\ndf_caloosa_weekly = df_combined.resample('W-MON').mean()\n\n# Optional: check the result\nprint(df_caloosa_weekly.head())\n\n# Save as a new weekly file to match the professor's format\ndf_caloosa_weekly.to_csv('caloosa_weekly.csv')\n\n\n\n\n","type":"content","url":"/data-swfl-combined#id-5-resample-caloosahatchee-data-to-weekly","position":39},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"5.1 Add Time Column to Caloosahatchee Dataset","lvl2":"5. Resample Caloosahatchee Data to Weekly"},"type":"lvl3","url":"/data-swfl-combined#id-5-1-add-time-column-to-caloosahatchee-dataset","position":40},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"5.1 Add Time Column to Caloosahatchee Dataset","lvl2":"5. Resample Caloosahatchee Data to Weekly"},"content":"\n\nimport pandas as pd\n\n# Load Caloosahatchee data with datetime index\ndf_caloosa = pd.read_csv('caloosa_weekly.csv', index_col=0, parse_dates=True)\n\n# Add 'time' column from index\ndf_caloosa['time'] = df_caloosa.index\n\n# Optional: move 'time' to the front\ndf_caloosa = df_caloosa[['time', 'caloosa_discharge', 'caloosa_total_nitrogen', 'caloosa_total_phosphorus']]\n\n# Save updated file\ndf_caloosa.to_csv('caloosa_weekly_with_time.csv', index=False)\n\n\n\n","type":"content","url":"/data-swfl-combined#id-5-1-add-time-column-to-caloosahatchee-dataset","position":41},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"5.2 Convert Caloosa TN and TP to mg/L","lvl2":"5. Resample Caloosahatchee Data to Weekly"},"type":"lvl3","url":"/data-swfl-combined#id-5-2-convert-caloosa-tn-and-tp-to-mg-l","position":42},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl3":"5.2 Convert Caloosa TN and TP to mg/L","lvl2":"5. Resample Caloosahatchee Data to Weekly"},"content":"\n\n# Load Caloosahatchee features with time column\ndf_caloosa = pd.read_csv(\"caloosa_weekly_with_time.csv\", parse_dates=['time'])\n\n# Convert TN and TP from µg/L to mg/L\ndf_caloosa['caloosa_total_nitrogen'] = df_caloosa['caloosa_total_nitrogen'] / 1000\ndf_caloosa['caloosa_total_phosphorus'] = df_caloosa['caloosa_total_phosphorus'] / 1000\n\n# Save updated version (overwrites file with corrected units)\ndf_caloosa.to_csv(\"caloosa_weekly_with_time.csv\", index=False)\n\n\n\n","type":"content","url":"/data-swfl-combined#id-5-2-convert-caloosa-tn-and-tp-to-mg-l","position":43},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"6. Merge with Peace River Data"},"type":"lvl2","url":"/data-swfl-combined#id-6-merge-with-peace-river-data","position":44},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"6. Merge with Peace River Data"},"content":"\n\n# Load Peace River + atmospheric + ocean features\ndf_peace = pd.read_csv('data_weekly_intepolated.csv', parse_dates=['time'])\n\n# Load Caloosahatchee features\ndf_caloosa = pd.read_csv('caloosa_weekly_with_time.csv', parse_dates=['time'])\n\n# Merge on 'time' column\ndf_swfl_merged = pd.merge(df_peace, df_caloosa, on='time', how='outer')\n\n# Drop rows with missing values\ndf_swfl_merged.dropna(inplace=True)\n\n# Save merged dataset\ndf_swfl_merged.to_csv('swfl_merged_features.csv', index=False)\n\n# Preview merged dataset (optional)\ndf_swfl_merged.head()\n\n\n\ndf_swfl_merged.tail()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-6-merge-with-peace-river-data","position":45},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"7. Add Tampa KB Counts"},"type":"lvl2","url":"/data-swfl-combined#id-7-add-tampa-kb-counts","position":46},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"7. Add Tampa KB Counts"},"content":"\n\nimport pandas as pd\n\n# Load SWFL merged features\ndf_swfl = pd.read_csv('swfl_merged_features.csv', parse_dates=['time'])\n\n# Load full HABSOS dataset\ndf_tampa = pd.read_csv('habsos_20240430.csv', parse_dates=['SAMPLE_DATE'])\n\n# Filter to Tampa Bay region using your specified bounding box\ndf_tampa = df_tampa[\n    (df_tampa['LATITUDE'].between(27.4, 28.2)) &\n    (df_tampa['LONGITUDE'].between(-83.0, -82.3))\n]\n\n# Rename columns for clarity\ndf_tampa.rename(columns={'SAMPLE_DATE': 'time', 'CELLCOUNT': 'kb_tampa'}, inplace=True)\n\n# Group by date to get daily average KB concentration for Tampa region\ndf_tampa_daily = df_tampa.groupby('time', as_index=False)['kb_tampa'].mean()\n\n# Merge with the existing SWFL dataset on 'time'\ndf_swfl_tampa = pd.merge(df_swfl, df_tampa_daily, on='time', how='left')\n\n# Save to new CSV file\ndf_swfl_tampa.to_csv('swfl_merged_features_tampa.csv', index=False)\n\n# Optional: preview the result\ndf_swfl_tampa.head()\n\n\n\n\n\ndf_swfl_tampa['kb_tampa'] = df_swfl_tampa['kb_tampa'].fillna(0)\n\n\n\ndf_swfl_tampa.to_csv('swfl_merged_features_tampa.csv', index=False)\ndf_swfl_tampa.head()\n\n\n\n# Add kb_tampa values to kb\ndf_swfl_tampa['kb'] = df_swfl_tampa['kb'] + df_swfl_tampa['kb_tampa']\n\n# Drop the kb_tampa column\ndf_swfl_tampa.drop(columns=['kb_tampa'], inplace=True)\ndf_swfl_tampa.to_csv('swfl_merged_features_tampa.csv', index=False)\ndf_swfl_tampa.head()\n\n\n\n","type":"content","url":"/data-swfl-combined#id-7-add-tampa-kb-counts","position":47},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"8. Create Combined Data Series"},"type":"lvl2","url":"/data-swfl-combined#id-8-create-combined-data-series","position":48},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"8. Create Combined Data Series"},"content":"\n\nimport os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# -----------------------------\n# Load merged weekly dataset\n# -----------------------------\n# If df_swfl_tampa already exists in your notebook, you can comment this out.\ndf = df_swfl_tampa.copy()\n\n# Ensure time is datetime + sorted\ndf[\"time\"] = pd.to_datetime(df[\"time\"])\ndf = df.sort_values(\"time\")\n\n# Keep only columns we need (and coerce to numeric where applicable)\ncols = [\n    \"time\",\n    \"kb\",\n    \"zos\",\n    \"salinity\",\n    \"water_temp\",\n    \"wind_direction\",\n    \"wind_speed\",\n    \"peace_discharge\",\n    \"caloosa_discharge\",\n    \"peace_TN\",\n    \"caloosa_total_nitrogen\",\n    \"peace_TP\",\n    \"caloosa_total_phosphorus\",\n]\ndf_plot = df[cols].copy()\n\nfor c in cols:\n    if c != \"time\":\n        df_plot[c] = pd.to_numeric(df_plot[c], errors=\"coerce\")\n\n# -----------------------------\n# Optional: match ML-ready behavior (drop rows with missing values)\n# -----------------------------\ndf_plot = df_plot.dropna()\n\n# -----------------------------\n# Output path\n# -----------------------------\nout_dir = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Parameters\"\nos.makedirs(out_dir, exist_ok=True)\nout_path = os.path.join(out_dir, \"stacked_parameters_9panel.png\")\n\n# -----------------------------\n# Plot setup (9 stacked panels)\n# -----------------------------\nfig, axes = plt.subplots(\n    nrows=9,\n    ncols=1,\n    figsize=(14, 22),\n    sharex=True,\n    constrained_layout=True\n)\n\n# 1) Karenia brevis Cell Count\naxes[0].plot(df_plot[\"time\"], df_plot[\"kb\"], linewidth=1.0)\naxes[0].set_title(\"K.brevis Cell Count\")\naxes[0].set_ylabel(\"Cells L$^{-1}$\")\n\n# 2) Sea Surface Height (zos)\naxes[1].plot(df_plot[\"time\"], df_plot[\"zos\"], linewidth=1.0)\naxes[1].set_title(\"Sea Surface Height Anomaly (zos)\")\naxes[1].set_ylabel(\"SSH (m)\")\n\n# 3) Salinity\naxes[2].plot(df_plot[\"time\"], df_plot[\"salinity\"], linewidth=1.0)\naxes[2].set_title(\"Salinity\")\naxes[2].set_ylabel(\"Salinity (PSU)\")\n\n# 4) Water Temperature\naxes[3].plot(df_plot[\"time\"], df_plot[\"water_temp\"], linewidth=1.0)\naxes[3].set_title(\"Water Temperature\")\naxes[3].set_ylabel(\"Temp (°C)\")\n\n# 5) Wind Direction\naxes[4].plot(df_plot[\"time\"], df_plot[\"wind_direction\"], linewidth=1.0)\naxes[4].set_title(\"Wind Direction\")\naxes[4].set_ylabel(\"Direction (°)\")\naxes[4].set_ylim(0, 360)\n\n# 6) Wind Speed\naxes[5].plot(df_plot[\"time\"], df_plot[\"wind_speed\"], linewidth=1.0)\naxes[5].set_title(\"Wind Speed\")\naxes[5].set_ylabel(\"Speed (m s$^{-1}$)\")\n\n# 7) Peace + Caloosa Discharge (cfs)\naxes[6].plot(df_plot[\"time\"], df_plot[\"peace_discharge\"], linewidth=1.0, label=\"Peace River\")\naxes[6].plot(df_plot[\"time\"], df_plot[\"caloosa_discharge\"], linewidth=1.0, label=\"Caloosahatchee River\")\naxes[6].set_title(\"River Discharge\")\naxes[6].set_ylabel(\"Discharge (cfs)\")\naxes[6].legend(loc=\"upper left\", frameon=False)\n\n# 8) Peace + Caloosa Total Nitrogen (mg/L)\naxes[7].plot(df_plot[\"time\"], df_plot[\"peace_TN\"], linewidth=1.0, label=\"Peace River TN\")\naxes[7].plot(df_plot[\"time\"], df_plot[\"caloosa_total_nitrogen\"], linewidth=1.0, label=\"Caloosahatchee TN\")\naxes[7].set_title(\"Total Nitrogen\")\naxes[7].set_ylabel(\"TN (mg/L)\")\naxes[7].legend(loc=\"upper left\", frameon=False)\n\n# 9) Peace + Caloosa Total Phosphorus (mg/L)\naxes[8].plot(df_plot[\"time\"], df_plot[\"peace_TP\"], linewidth=1.0, label=\"Peace River TP\")\naxes[8].plot(df_plot[\"time\"], df_plot[\"caloosa_total_phosphorus\"], linewidth=1.0, label=\"Caloosahatchee TP\")\naxes[8].set_title(\"Total Phosphorus\")\naxes[8].set_ylabel(\"TP (mg/L)\")\naxes[8].legend(loc=\"upper left\", frameon=False)\n\n# -----------------------------\n# X-axis formatting\n# -----------------------------\naxes[8].set_xlabel(\"Time\")\naxes[8].xaxis.set_major_locator(mdates.YearLocator(base=2))\naxes[8].xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\n\nfor ax in axes:\n    ax.grid(True, linewidth=0.5)\n\n# -----------------------------\n# Save figure\n# -----------------------------\nfig.suptitle(\"Combined Environmental Drivers\", y=1.01, fontsize=14)\nplt.savefig(out_path, dpi=300, bbox_inches=\"tight\")\nplt.show()\n\nprint(f\"Saved figure to: {out_path}\")\n\n\n\n\n\ndf_swfl_tampa[['time', 'caloosa_total_nitrogen']] \\\n    .sort_values('caloosa_total_nitrogen', ascending=False) \\\n    .head(5)\n\n\n\n","type":"content","url":"/data-swfl-combined#id-8-create-combined-data-series","position":49},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"9. Plot Study Area"},"type":"lvl2","url":"/data-swfl-combined#id-9-plot-study-area","position":50},{"hierarchy":{"lvl1":"Data Integration for Southwest Florida","lvl2":"9. Plot Study Area"},"content":"\n\nimport pandas as pd\n\n# --------------------------------------------------\n# Load HABsOS bloom observation dataset\n# --------------------------------------------------\ndf_hab = pd.read_csv(\n    \"habsos_20240430.csv\",\n    parse_dates=[\"SAMPLE_DATE\"]\n)\n\nprint(\"Initial HABsOS shape:\", df_hab.shape)\n\n# --------------------------------------------------\n# Filter to Karenia brevis only\n# --------------------------------------------------\ndf_hab = df_hab[\n    (df_hab['GENUS'] == 'Karenia') &\n    (df_hab['SPECIES'] == 'brevis')\n]\n\nprint(\"After filtering to Karenia brevis:\", df_hab.shape)\n\n# --------------------------------------------------\n# Filter to SWFL + Tampa Bay spatial domain\n# --------------------------------------------------\ndf_hab_swfl = df_hab[\n    (df_hab['LATITUDE'].between(24.5, 28.5)) &    # SWFL → Tampa Bay\n    (df_hab['LONGITUDE'].between(-84.5, -80.0)) &\n    (df_hab['SAMPLE_DATE'] >= '1992-01-01')\n]\n\nprint(\"After spatial/temporal filtering:\", df_hab_swfl.shape)\n\n# --------------------------------------------------\n# Create bloom intensity subsets for plotting\n# --------------------------------------------------\nhigh = df_hab_swfl[df_hab_swfl['CELLCOUNT'] >= 1e6]\n\nmedium = df_hab_swfl[\n    (df_hab_swfl['CELLCOUNT'] >= 1e5) &\n    (df_hab_swfl['CELLCOUNT'] < 1e6)\n]\n\nlow = df_hab_swfl[\n    (df_hab_swfl['CELLCOUNT'] >= 1e4) &\n    (df_hab_swfl['CELLCOUNT'] < 1e5)\n]\n\n# --------------------------------------------------\n# Sanity checks\n# --------------------------------------------------\nprint(\"\\nBloom category counts:\")\nprint(f\"  High (≥1e6): {len(high)}\")\nprint(f\"  Medium (1e5–1e6): {len(medium)}\")\nprint(f\"  Low (1e4–1e5): {len(low)}\")\n\nprint(\"\\nCELLCOUNT summary:\")\nprint(df_hab_swfl['CELLCOUNT'].describe())\n\n\n\n\n\n# Recreate KB (Karenia brevis) cellcount map up to Tampa Bay (Cartopy)\n# Assumes you already have df_hab loaded (HABsOS) with at least:\n# ['LATITUDE','LONGITUDE','SAMPLE_DATE','CELLCOUNT','GENUS','SPECIES'].\n# If df_hab is not in memory yet, load it first like we did earlier.\n\nimport os\nfrom pathlib import Path\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nfrom matplotlib.patches import Rectangle\n\n# -----------------------\n# 0) Output folder\n# -----------------------\noutput_dir = Path(r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Tampa_Data_Graphics\")\noutput_dir.mkdir(parents=True, exist_ok=True)\n\n# -----------------------\n# 1) Map extent + focus box (SWFL->Tampa)\n# -----------------------\n# Big Gulf view (similar feel to advisor figure)\nextent = [-98, -79, 22, 30]  # [Lon_W, Lon_E, Lat_S, Lat_N]\n\n# Focus box you can tweak (covers Naples -> Tampa Bay)\nbox_lon_w, box_lon_e = -83.6, -81.1\nbox_lat_s, box_lat_n = 25.3, 28.4\n\n# -----------------------\n# 2) Filter HABsOS to K. brevis + time + focus region (for plotting points)\n# -----------------------\ndf_plot = df_hab.copy()\n\n# Ensure datetime\ndf_plot[\"SAMPLE_DATE\"] = pd.to_datetime(df_plot[\"SAMPLE_DATE\"], errors=\"coerce\")\n\n# Keep Karenia brevis only (robust to case/spacing)\ndf_plot = df_plot[\n    df_plot[\"GENUS\"].astype(str).str.strip().str.lower().eq(\"karenia\") &\n    df_plot[\"SPECIES\"].astype(str).str.strip().str.lower().eq(\"brevis\")\n].copy()\n\n# Time filter (matches your earlier workflow)\ndf_plot = df_plot[df_plot[\"SAMPLE_DATE\"] >= pd.to_datetime(\"1992-01-01\")].copy()\n\n# Keep only points inside the focus box (so we don’t paint the whole Gulf with dots)\ndf_plot = df_plot[\n    (df_plot[\"LONGITUDE\"].between(box_lon_w, box_lon_e)) &\n    (df_plot[\"LATITUDE\"].between(box_lat_s, box_lat_n))\n].copy()\n\n# Make sure CELLCOUNT is numeric\ndf_plot[\"CELLCOUNT\"] = pd.to_numeric(df_plot[\"CELLCOUNT\"], errors=\"coerce\").fillna(0)\n\n# Categories\nhigh = df_plot[df_plot[\"CELLCOUNT\"] >= 1e6]\nmedium = df_plot[(df_plot[\"CELLCOUNT\"] >= 1e5) & (df_plot[\"CELLCOUNT\"] < 1e6)]\nlow = df_plot[(df_plot[\"CELLCOUNT\"] >= 1e4) & (df_plot[\"CELLCOUNT\"] < 1e5)]\n\n# -----------------------\n# 3) Build map\n# -----------------------\nproj = ccrs.PlateCarree()\nfig = plt.figure(figsize=(11, 8.5))\nax = plt.subplot(1, 1, 1, projection=proj)\nax.set_extent(extent, crs=proj)\n\n# Background / features\nax.set_facecolor(cfeature.COLORS[\"water\"])\nax.add_feature(cfeature.LAKES.with_scale(\"10m\"), color=\"aqua\", zorder=2)\nax.add_feature(cfeature.COASTLINE.with_scale(\"10m\"), color=\"gray\", zorder=3)\nax.add_feature(cfeature.BORDERS, edgecolor=\"red\", facecolor=\"none\", linewidth=1.5, zorder=3)\nax.stock_img()\n\nax.add_feature(\n    cfeature.NaturalEarthFeature(\n        \"physical\", \"rivers_lake_centerlines\", scale=\"10m\", edgecolor=\"blue\", facecolor=\"none\"\n    ),\n    zorder=3,\n)\nax.add_feature(\n    cfeature.NaturalEarthFeature(\n        \"physical\", \"rivers_north_america\", scale=\"10m\", edgecolor=\"blue\", facecolor=\"none\", alpha=0.4\n    ),\n    zorder=3,\n)\n\n# Gridlines\ngl = ax.gridlines(\n    draw_labels=True,\n    xlocs=np.arange(extent[0], extent[1] + 1, 5),\n    ylocs=np.arange(extent[2], extent[3] + 1, 5),\n    linewidth=1,\n    color=\"gray\",\n    alpha=0.5,\n    linestyle=\"--\",\n    zorder=10,\n)\ngl.right_labels = False\ngl.top_labels = False\ngl.xlabel_style = {\"size\": 10}\ngl.ylabel_style = {\"size\": 10}\n\n# Bathymetry “bands” (Natural Earth)\nbathymetry_names = [\n    \"bathymetry_L_0\",\n    \"bathymetry_K_200\",\n    \"bathymetry_J_1000\",\n    \"bathymetry_I_2000\",\n    \"bathymetry_H_3000\",\n    \"bathymetry_G_4000\",\n]\n# Very light -> darker blue\nbath_colors = [\n    (0.90, 0.95, 1.00),\n    (0.75, 0.88, 1.00),\n    (0.60, 0.80, 1.00),\n    (0.45, 0.72, 1.00),\n    (0.25, 0.62, 1.00),\n    (0.05, 0.52, 1.00),\n]\nfor name, col in zip(bathymetry_names, bath_colors):\n    ax.add_feature(\n        cfeature.NaturalEarthFeature(\n            category=\"physical\",\n            name=name,\n            scale=\"10m\",\n            edgecolor=\"none\",\n            facecolor=col,\n        ),\n        zorder=1,\n    )\n\n# Focus box rectangle\nrect = Rectangle(\n    (box_lon_w, box_lat_s),\n    box_lon_e - box_lon_w,\n    box_lat_n - box_lat_s,\n    fill=False,\n    linewidth=1.5,\n    edgecolor=\"black\",\n    transform=proj,\n    zorder=20,\n)\nax.add_patch(rect)\n\n# Cities + buoy\nlocations = {\n    \"Tampa\": (27.9506, -82.4572),\n    \"Naples\": (26.1420, -81.7948),\n}\nfor name, (lat, lon) in locations.items():\n    ax.plot(lon, lat, marker=\"o\", color=\"black\", markersize=3, transform=proj, zorder=30)\n    ax.text(lon + 0.15, lat + 0.10, name, transform=proj, fontsize=9, color=\"black\", zorder=30)\n\nbuoys = {\"Buoy 42003\": (25.9253, -85.6161)}\nfor name, (lat, lon) in buoys.items():\n    ax.plot(lon, lat, marker=\"o\", color=\"black\", markersize=3, transform=proj, zorder=30)\n    ax.text(lon - 2.0, lat + 0.10, name, transform=proj, fontsize=9, color=\"black\", zorder=30)\n\n# -----------------------\n# 4) Plot KB points (cellcount bins)\n# -----------------------\nsc_high = ax.scatter(\n    high[\"LONGITUDE\"], high[\"LATITUDE\"],\n    s=10, color=\"red\", edgecolor=\"none\",\n    transform=proj, zorder=40\n)\nsc_med = ax.scatter(\n    medium[\"LONGITUDE\"], medium[\"LATITUDE\"],\n    s=10, color=\"orange\", edgecolor=\"none\",\n    transform=proj, zorder=39\n)\nsc_low = ax.scatter(\n    low[\"LONGITUDE\"], low[\"LATITUDE\"],\n    s=10, color=\"yellow\", edgecolor=\"none\",\n    transform=proj, zorder=38\n)\n\nlegend = ax.legend(\n    handles=[sc_high, sc_med, sc_low],\n    labels=[\"Cellcount ≥ 1e6\", \"1e5 ≤ Cellcount < 1e6\", \"1e4 ≤ Cellcount < 1e5\"],\n    loc=\"upper left\",\n    fontsize=9,\n    frameon=True,\n)\nlegend.set_zorder(50)\n\n# -----------------------\n# 5) Save + show\n# -----------------------\nfname = f\"KB_cellcount_SWFL_Tampa_{pd.Timestamp.now():%Y-%m-%d_%H-%M-%S}.png\"\noutpath = output_dir / fname\nplt.savefig(outpath, dpi=300, bbox_inches=\"tight\")\nprint(f\"Figure saved to: {outpath}\")\n\nplt.show()\n\n\n\n\n\n","type":"content","url":"/data-swfl-combined#id-9-plot-study-area","position":51},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River"},"type":"lvl1","url":"/ml-model-swfl-with-tampa","position":0},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River"},"content":"This notebook implements a machine learning framework to predict Karenia brevis bloom occurrence across Southwest Florida using integrated environmental and nutrient datasets from the Peace River and Caloosahatchee River watersheds. The analysis combines in situ water quality measurements, hydrologic discharge variables, and confirmed bloom observations, and extends the spatial domain to include the Tampa Bay region. By incorporating data from multiple coastal systems, this workflow evaluates model performance across a broader geographic range and supports regional-scale assessment of bloom prediction capability.\n\nimport os\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\n\n# Define your graphics output directory\ngraphics_dir = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Final_Graphics\"\nos.makedirs(graphics_dir, exist_ok=True)\n\n# Define a custom show function to automatically save every figure\n_original_show = plt.show\n\ndef autosave_show(*args, **kwargs):\n    # Get current figure\n    fig = plt.gcf()\n    timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')\n    filename = f\"figure_{timestamp}.png\"\n    filepath = os.path.join(graphics_dir, filename)\n    fig.savefig(filepath, dpi=300, bbox_inches='tight')\n    print(f\"Figure saved to: {filepath}\")\n    _original_show(*args, **kwargs)\n\n# Override the default plt.show\nplt.show = autosave_show\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa","position":1},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"1. Machine Learning Model"},"type":"lvl2","url":"/ml-model-swfl-with-tampa#id-1-machine-learning-model","position":2},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"1. Machine Learning Model"},"content":"\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-1-machine-learning-model","position":3},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.1 Data Loading and Preprocessing","lvl2":"1. Machine Learning Model"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-1-1-data-loading-and-preprocessing","position":4},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.1 Data Loading and Preprocessing","lvl2":"1. Machine Learning Model"},"content":"\n\nThe merged dataset is loaded and a binary target variable is created to indicate the presence of a Karenia brevis bloom. A bloom event is defined based on whether cell concentrations exceed 100,000 cells/L, with the target shifted one week ahead to support forecasting.\n\nimport pandas as pd\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import classification_report, balanced_accuracy_score\nfrom sklearn.model_selection import train_test_split\n\n# Load SWFL merged dataset (with Tampa KB added)\ndf = pd.read_csv('swfl_merged_features_tampa.csv', parse_dates=['time'])\ndf = df.sort_values('time').reset_index(drop=True)\n\n# Create binary bloom target (e.g., bloom if kb ≥ 100,000 cells/L)\nthreshold = 100000\ndf['bloom'] = (df['kb'] >= threshold).astype(int)\n\n# Create next-week target for 1-week-ahead forecasting\ndf['target_next_week'] = df['bloom'].shift(-1)\ndf = df.dropna(subset=['target_next_week'])\ndf['target_next_week'] = df['target_next_week'].astype(int)\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-1-1-data-loading-and-preprocessing","position":5},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.2 Lag Feature Engineering","lvl2":"1. Machine Learning Model"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-1-2-lag-feature-engineering","position":6},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.2 Lag Feature Engineering","lvl2":"1. Machine Learning Model"},"content":"\n\nLagged variables and rolling averages are generated for key predictors such as nutrient concentrations, discharge, and ocean conditions. These temporal features provide context on recent environmental trends that may influence bloom dynamics.\n\n# Lag features (1 and 2 weeks back)\ndf['kb_prev1'] = df['kb'].shift(1)\ndf['kb_prev2'] = df['kb'].shift(2)\n\ndf['zos_prev1'] = df['zos'].shift(1)\ndf['salinity_prev1'] = df['salinity'].shift(1)\ndf['water_temp_prev1'] = df['water_temp'].shift(1)\ndf['wind_speed_prev1'] = df['wind_speed'].shift(1)\n\ndf['peace_discharge_prev1'] = df['peace_discharge'].shift(1)\ndf['peace_TN_prev1'] = df['peace_TN'].shift(1)\ndf['peace_TP_prev1'] = df['peace_TP'].shift(1)\n\n# Caloosahatchee lag features\ndf['caloosa_discharge_prev1'] = df['caloosa_discharge'].shift(1)\ndf['caloosa_TN_prev1'] = df['caloosa_total_nitrogen'].shift(1)\ndf['caloosa_TP_prev1'] = df['caloosa_total_phosphorus'].shift(1)\n\n# Rolling average (4-week) of Peace discharge\ndf['discharge_4w_avg'] = df['peace_discharge'].rolling(window=4).mean()\n\n# Drop rows with NaNs created by shifting\ndf.dropna(inplace=True)\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-1-2-lag-feature-engineering","position":7},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.3 Feature Selection","lvl2":"1. Machine Learning Model"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-1-3-feature-selection","position":8},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.3 Feature Selection","lvl2":"1. Machine Learning Model"},"content":"\n\nRelevant features, including both current and lagged environmental variables, are selected for use in the machine learning model. These features represent potential drivers of bloom events across both the Peace River and Caloosahatchee River systems.\n\nfeature_cols = [\n    'kb', 'kb_prev1', 'kb_prev2',\n    'zos', 'salinity', 'water_temp',\n    'wind_speed', 'wind_direction',\n    'peace_discharge', 'peace_TN', 'peace_TP',\n    'peace_discharge_prev1', 'peace_TN_prev1', 'peace_TP_prev1',\n    'caloosa_discharge', 'caloosa_total_nitrogen', 'caloosa_total_phosphorus',\n    'caloosa_discharge_prev1', 'caloosa_TN_prev1', 'caloosa_TP_prev1',\n    'discharge_4w_avg'\n]\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-1-3-feature-selection","position":9},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.4 Train-Test Split and Scaling","lvl2":"1. Machine Learning Model"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-1-4-train-test-split-and-scaling","position":10},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.4 Train-Test Split and Scaling","lvl2":"1. Machine Learning Model"},"content":"\n\nThe dataset is split chronologically into training and testing sets to preserve temporal structure. A RobustScaler is applied to normalize the feature distributions and reduce sensitivity to outliers commonly present in hydrological and ecological data.\n\n# Split into train/test by date\ntrain_df = df[df['time'] < '2019-01-01']\ntest_df  = df[df['time'] >= '2019-01-01']\n\nX_train = train_df[feature_cols]\ny_train = train_df['target_next_week']\nX_test  = test_df[feature_cols]\ny_test  = test_df['target_next_week']\n\n# Scale Features\nscaler = RobustScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled  = scaler.transform(X_test)\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-1-4-train-test-split-and-scaling","position":11},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.5 Model Training","lvl2":"1. Machine Learning Model"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-1-5-model-training","position":12},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.5 Model Training","lvl2":"1. Machine Learning Model"},"content":"\n\nA Random Forest classifier is trained on the scaled training set and evaluated on the test set. Model performance is assessed using classification metrics to determine predictive accuracy for one-week-ahead bloom conditions.\n\n# Train Random Forest\nrf_clf = RandomForestClassifier(n_estimators=100, class_weight='balanced', random_state=42)\nrf_clf.fit(X_train_scaled, y_train)\n\n# Predict and evaluate\ny_pred = rf_clf.predict(X_test_scaled)\n\nfrom sklearn.metrics import classification_report, balanced_accuracy_score\nprint(classification_report(y_test, y_pred))\nprint(\"Balanced Accuracy:\", balanced_accuracy_score(y_test, y_pred))\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-1-5-model-training","position":13},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.6 Results Summary","lvl2":"1. Machine Learning Model"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-1-6-results-summary","position":14},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"1.6 Results Summary","lvl2":"1. Machine Learning Model"},"content":"\n\nIncorporating Karenia brevis cell counts from the Tampa Bay region resulted in a modest improvement in model performance. The balanced accuracy increased from 0.855 (original dataset) to 0.876 with Tampa data. Notably, the recall for bloom events (class 1) improved from 0.75 to 0.79, indicating the model’s enhanced ability to correctly identify bloom conditions. Precision and overall accuracy remained stable at 0.90, suggesting that including Tampa KB data improved bloom detection sensitivity without compromising classification reliability.\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-1-6-results-summary","position":15},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"2. ML Evaluation"},"type":"lvl2","url":"/ml-model-swfl-with-tampa#id-2-ml-evaluation","position":16},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"2. ML Evaluation"},"content":"\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-2-ml-evaluation","position":17},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.1 Confusion Matrix","lvl2":"2. ML Evaluation"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-2-1-confusion-matrix","position":18},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.1 Confusion Matrix","lvl2":"2. ML Evaluation"},"content":"\n\nfrom sklearn.metrics import classification_report\nimport pandas as pd\n\n# Get classification report as dictionary\nreport_dict = classification_report(\n    y_test, y_pred, target_names=[\"No Bloom\", \"Bloom\"], output_dict=True\n)\n\n# Convert to DataFrame\nreport_df = pd.DataFrame(report_dict).transpose()\n\n# Optional: round for display\nreport_df = report_df.round(2)\n\n# Display the table\nreport_df\n\n\n\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\n\n# Generate confusion matrix\ncm = confusion_matrix(y_test, y_pred)\n\n# Plot with updated title\ndisp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=[\"No Bloom\", \"Bloom\"])\ndisp.plot(cmap=\"Blues\", values_format=\"d\")\nplt.show()\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-2-1-confusion-matrix","position":19},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"Confusion Matrix: Random Forest Performance on Karenia brevis Bloom Forecasting","lvl2":"2. ML Evaluation"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#confusion-matrix-random-forest-performance-on-karenia-brevis-bloom-forecasting","position":20},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"Confusion Matrix: Random Forest Performance on Karenia brevis Bloom Forecasting","lvl2":"2. ML Evaluation"},"content":"The confusion matrix visually represents the performance of your machine learning classification model—in this case, the Random Forest classifier used to predict Karenia brevis bloom severity. A confusion matrix summarizes the number of correct and incorrect predictions, broken down by each class (“No Bloom” and “Bloom”).\n\nThe confusion matrix has four key components:\n\n\n\nPredicted No Bloom\n\nPredicted Bloom\n\nActual No Bloom\n\nTrue Negative (TN) – 165\n\nFalse Positive (FP) – 7\n\nActual Bloom\n\nFalse Negative (FN) – 18\n\nTrue Positive (TP) – 69\n\nTrue Negative (TN) = 165\n\nThe model correctly predicted “No Bloom” when there was actually no bloom.\n\nFalse Positive (FP) = 7\n\nThe model predicted “Bloom” when there was actually no bloom (a false alarm).\n\nFalse Negative (FN) = 18\n\nThe model predicted “No Bloom” when there was actually a bloom (a missed bloom event).\n\nTrue Positive (TP) = 69\n\nThe model correctly predicted “Bloom” when there was actually a bloom.","type":"content","url":"/ml-model-swfl-with-tampa#confusion-matrix-random-forest-performance-on-karenia-brevis-bloom-forecasting","position":21},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl6":"Key Metrics Derived from the Confusion Matrix:","lvl3":"Confusion Matrix: Random Forest Performance on Karenia brevis Bloom Forecasting","lvl2":"2. ML Evaluation"},"type":"lvl6","url":"/ml-model-swfl-with-tampa#key-metrics-derived-from-the-confusion-matrix","position":22},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl6":"Key Metrics Derived from the Confusion Matrix:","lvl3":"Confusion Matrix: Random Forest Performance on Karenia brevis Bloom Forecasting","lvl2":"2. ML Evaluation"},"content":"Accuracy – Measures the overall percentage of correct predictions:\\text{Accuracy} = \\frac{TP + TN}{TP + TN + FP + FN} = \\frac{69 + 165}{69 + 165 + 7 + 18} = \\frac{234}{259} \\approx 0.90 \\quad (90\\%)\n\nPrecision – Measures how many of the predicted positive cases (blooms) were actually correct:\\text{Precision} = \\frac{TP}{TP + FP} = \\frac{69}{69 + 7} \\approx 0.91 \\quad (91\\%)\n\nHigh precision means fewer false positives (the model doesn’t incorrectly predict blooms very often).\n\nRecall (Sensitivity or True Positive Rate) – Measures how many of the actual positive cases (blooms) were correctly identified:\n\\text{Recall} = \\frac{TP}{TP + FN} = \\frac{69}{69 + 18} \\approx 0.79 \\quad (79\\%)\n\nHigh recall means the model catches most of the bloom events.\n\nF1-Score – The harmonic mean of precision and recall; it balances the trade-off between precision and recall:\n\\text{F1} = 2 \\cdot \\frac{\\text{Precision} \\cdot \\text{Recall}}{\\text{Precision} + \\text{Recall}} = 2 \\cdot \\frac{0.91 \\cdot 0.79}{0.91 + 0.79} \\approx 0.85 \\quad (85\\%)\n\nA high F1-score means the model achieves a good balance between precision and recall.\n\nSupport – The number of actual samples in each class:\n\nNo Bloom: 172 total instances\n\nBloom: 87 total instances","type":"content","url":"/ml-model-swfl-with-tampa#key-metrics-derived-from-the-confusion-matrix","position":23},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl6":"Summary of Model Performance:","lvl3":"Confusion Matrix: Random Forest Performance on Karenia brevis Bloom Forecasting","lvl2":"2. ML Evaluation"},"type":"lvl6","url":"/ml-model-swfl-with-tampa#summary-of-model-performance","position":24},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl6":"Summary of Model Performance:","lvl3":"Confusion Matrix: Random Forest Performance on Karenia brevis Bloom Forecasting","lvl2":"2. ML Evaluation"},"content":"The model correctly predicted 90% of the test samples (accuracy).\n\nIt had a high precision of 91%, meaning it rarely issued false bloom alerts.\n\nThe recall of 79% indicates that the model detected most bloom events and reduced false negatives compared to the baseline model.\n\nThe F1-score of 85% reflects that the model maintains a strong balance between precision and recall.","type":"content","url":"/ml-model-swfl-with-tampa#summary-of-model-performance","position":25},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl6":"Conclusion:","lvl3":"Confusion Matrix: Random Forest Performance on Karenia brevis Bloom Forecasting","lvl2":"2. ML Evaluation"},"type":"lvl6","url":"/ml-model-swfl-with-tampa#conclusion","position":26},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl6":"Conclusion:","lvl3":"Confusion Matrix: Random Forest Performance on Karenia brevis Bloom Forecasting","lvl2":"2. ML Evaluation"},"content":"The model demonstrates strong performance in predicting Karenia brevis bloom conditions using the enhanced dataset that includes Tampa KB values.\n\nThe increase in recall and F1-score over the original SWFL-only model suggests that the additional data improved bloom detection.\n\nContinued feature refinement or threshold tuning may help push recall even higher while maintaining precision.\n\n","type":"content","url":"/ml-model-swfl-with-tampa#conclusion","position":27},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.2 Precision-Recall Curve","lvl2":"2. ML Evaluation"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-2-2-precision-recall-curve","position":28},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.2 Precision-Recall Curve","lvl2":"2. ML Evaluation"},"content":"\n\nhis is a Precision-Recall (PR) Curve, which illustrates the trade-off between precision and recall at different classification thresholds for the Random Forest model trained on the combined Southwest Florida dataset (Peace River + Caloosahatchee River).","type":"content","url":"/ml-model-swfl-with-tampa#id-2-2-precision-recall-curve","position":29},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl5":"What the PR Curve Represents:","lvl3":"2.2 Precision-Recall Curve","lvl2":"2. ML Evaluation"},"type":"lvl5","url":"/ml-model-swfl-with-tampa#what-the-pr-curve-represents","position":30},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl5":"What the PR Curve Represents:","lvl3":"2.2 Precision-Recall Curve","lvl2":"2. ML Evaluation"},"content":"Precision (Y-axis) = The proportion of predicted positive cases that are truly positive:\\text{Precision} = \\frac{TP}{TP + FP}\n\nRecall (X-axis) = The proportion of actual positive cases that are correctly predicted:\\text{Recall} = \\frac{TP}{TP + FN}\n\nThe PR curve evaluates the model’s performance across a range of thresholds, showing how precision changes as recall increases. High recall means the model captures more true blooms but may increase false positives, lowering precision. Conversely, high precision means fewer false alarms but may miss some bloom events.\n\nIn this model, the classifier maintains strong precision (~0.91) even as recall increases toward 0.79 — demonstrating the model’s ability to detect true bloom events while minimizing false alarms. A notable drop in precision occurs only at the highest recall levels (>0.90), indicating that aggressively trying to catch every bloom comes at the cost of including more false positives — a common trade-off in environmental risk forecasting.\n\nThis curve aligns with the model’s F1-score of 85% and balanced accuracy of 87.6%, both of which reflect improved predictive strength compared to the baseline model. The curve suggests that the model balances bloom sensitivity and specificity effectively under the default threshold. Depending on monitoring goals, the classification threshold can be adjusted to prioritize early detection (higher recall) or conservative alerts (higher precision). The F1-score or the area under the precision-recall curve (PR AUC) can help guide optimal threshold selection for operational use.\n\nfrom sklearn.metrics import precision_recall_curve\nimport matplotlib.pyplot as plt\nimport os\n\n# Optional: save to your custom graphics folder\ngraphics_dir = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Final_Graphics\"\nos.makedirs(graphics_dir, exist_ok=True)\n\n# Compute precision and recall\nprecision, recall, _ = precision_recall_curve(y_test, rf_clf.predict_proba(X_test_scaled)[:, 1])\n\n# Plot PR curve\nplt.figure(figsize=(8, 6))\nplt.plot(recall, precision, marker='.', linewidth=1.5)\nplt.xlabel('Recall', fontsize=12)\nplt.ylabel('Precision', fontsize=12)\nplt.grid(True)\n\n# Save plot\nplt.savefig(os.path.join(graphics_dir, \"PR_curve_SWFL_Tampa.png\"), dpi=300, bbox_inches='tight')\nplt.show()\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#what-the-pr-curve-represents","position":31},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.3 Feature Importance Plot","lvl2":"2. ML Evaluation"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-2-3-feature-importance-plot","position":32},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.3 Feature Importance Plot","lvl2":"2. ML Evaluation"},"content":"\n\nThe plot from the Random Forest Classifier shows the relative contribution of each input feature to predicting Karenia brevis bloom severity. Feature importance reflects how much each feature reduces classification error, based on improvements in the Gini index across all decision trees in the ensemble.\n\nKarenia brevis cell counts (kb) remain the most dominant predictor, with lagged values (kb_prev2, kb_prev1) also ranking near the top. This highlights the strong short-term autocorrelation of bloom conditions — a bloom this week is highly predictive of bloom presence in the near future.\n\nDischarge dynamics, especially the 4-week rolling average (discharge_4w_avg) and lagged Peace River discharge (peace_discharge_prev1), continue to be important secondary contributors. Nutrient inputs — including peace_TN_prev1, caloosa_TN_prev1, and caloosa_total_phosphorus — also influence bloom status, supporting the hypothesis that nitrogen and phosphorus availability play a key role in bloom maintenance and short-term intensification.\n\nOceanographic variables such as zos (sea level anomaly) and water_temp show modest importance, while salinity, wind_speed, and wind_direction contribute less overall. These likely represent more variable or indirect effects on bloom behavior (e.g., transport, mixing).\n\nThese results reinforce that the strongest bloom predictors are recent KB levels, followed by discharge and nutrient signals — while atmospheric and oceanic conditions provide supporting context in bloom forecasting.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\n# Get feature importances from the trained RF model\nimportances = rf_clf.feature_importances_\n\n# Sort feature indices from most to least important\nindices = np.argsort(importances)[::-1]\n\n# Optional: Save to your custom graphics directory\ngraphics_dir = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Final_Graphics\"\nos.makedirs(graphics_dir, exist_ok=True)\n\n# Plot feature importance\nplt.figure(figsize=(12, 6))\nplt.bar(range(X_train.shape[1]), importances[indices], align=\"center\")\nplt.xticks(range(X_train.shape[1]), [feature_cols[i] for i in indices], rotation=90)\nplt.tight_layout()\n\n# Save figure\nplt.savefig(os.path.join(graphics_dir, \"feature_importances_SWFL_Tampa.png\"), dpi=300, bbox_inches=\"tight\")\nplt.show()\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-2-3-feature-importance-plot","position":33},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.4 Partial Dependence Plots","lvl2":"2. ML Evaluation"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-2-4-partial-dependence-plots","position":34},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.4 Partial Dependence Plots","lvl2":"2. ML Evaluation"},"content":"\n\nPartial dependence plots (PDPs) illustrate how predicted Karenia brevis bloom probabilities respond to changes in river discharge and nutrient concentrations from both the Peace and Caloosahatchee Rivers, while holding all other variables constant. The y-axis represents the model’s predicted bloom probability, and the x-axis shows the standardized values of each input feature.\n\nFor both peace_discharge and caloosa_discharge, bloom probability increases sharply from low to moderate discharge values and then flattens out. This suggests that moderate freshwater inflows may promote bloom persistence or nutrient delivery, while higher discharge may not further increase bloom probability — potentially due to dilution or reduced residence time.\n\nNutrient variables show more varied but similarly nonlinear behavior. For example, peace_TN and caloosa_total_nitrogen are both associated with increasing bloom probability up to a threshold (~2–3 mg/L), after which the effect plateaus. This indicates a possible nitrogen saturation point, beyond which blooms are no longer limited by nitrogen availability.\n\nPhosphorus variables — peace_TP and caloosa_total_phosphorus — follow the same pattern: steep initial increases in bloom probability at low phosphorus concentrations, followed by tapering or even a gradual decline beyond ~1.5 mg/L. This may reflect a stoichiometric imbalance or ecological thresholds where additional phosphorus no longer promotes bloom activity.\n\nThe clustering of tick marks along the lower end of the x-axes indicates that most training data points fall within those value ranges, reinforcing that model predictions are more reliable there. These PDPs collectively show that bloom risk is most sensitive to moderate discharge and nutrient conditions, consistent with ecological dynamics of nutrient triggering, hydrologic influence, and possible saturation effects in bloom formation.\n\nfrom sklearn.inspection import PartialDependenceDisplay\nimport matplotlib.pyplot as plt\nimport os\n\n# Ensure output directory exists\ngraphics_dir = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Final_Graphics\"\nos.makedirs(graphics_dir, exist_ok=True)\n\n## Select features to plot\nselected_features = [\n    feature_cols.index('peace_discharge'),\n    feature_cols.index('peace_TN'),\n    feature_cols.index('peace_TP'),\n    feature_cols.index('caloosa_discharge'),\n    feature_cols.index('caloosa_total_nitrogen'),\n    feature_cols.index('caloosa_total_phosphorus')\n]\n\n# Create PDP plots\nfig, ax = plt.subplots(nrows=2, ncols=3, figsize=(12, 6))\n\nPartialDependenceDisplay.from_estimator(\n    rf_clf,\n    X_train_scaled,\n    features=selected_features,\n    feature_names=feature_cols,\n    grid_resolution=50,\n    ax=ax\n)\n\n# Adjust layout to avoid cutoff & save\nplt.tight_layout(pad=2.0)\nplt.savefig(os.path.join(graphics_dir, \"partial_dependence_SWFL_Tampa.png\"), dpi=300, bbox_inches='tight')\nplt.show()\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-2-4-partial-dependence-plots","position":35},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.5 Actual Vs. Predicted Bloom","lvl2":"2. ML Evaluation"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-2-5-actual-vs-predicted-bloom","position":36},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.5 Actual Vs. Predicted Bloom","lvl2":"2. ML Evaluation"},"content":"\n\nThis figure shows the actual vs. predicted Karenia brevis bloom status over time for the updated model that incorporates Tampa-area KB data into the Southwest Florida (SWFL) system. The model’s predictions (red dashed line) align closely with observed bloom events (blue line), capturing both the onset and duration of bloom episodes with high temporal fidelity.\n\nThe model slightly underpredicts bloom persistence in a few intervals — where actual bloom duration extends beyond predicted — but overprediction is minimal. In most cases, the model accurately identifies bloom start dates and avoids premature false positives. Compared to the baseline model, this updated version demonstrates improved alignment with observed blooms and fewer lagging or premature activations.\n\nThese results indicate that incorporating KB data from Tampa enhances the model’s ability to learn bloom dynamics across the region. The consistent agreement between actual and predicted time series confirms that the model captures short-term bloom memory and seasonal signals effectively, suggesting it is well-suited for real-time bloom surveillance and early warning applications in multi-basin systems like SWFL.\n\nimport matplotlib.pyplot as plt\nimport os\nimport pandas as pd\n\n# Ensure output folder exists\noutput_dir = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Final_Graphics\"\nos.makedirs(output_dir, exist_ok=True)\n\n# Create DataFrame to hold test results\ntest_df = pd.DataFrame({\n    'time': X_test.index,  # assumes X_test is indexed by time\n    'Actual': y_test,\n    'Predicted': y_pred\n})\n\n# Sort by time for plotting\ntest_df = test_df.sort_values('time')\n\n# Plot actual vs predicted bloom status\nplt.figure(figsize=(12, 6))\nplt.plot(test_df['time'], test_df['Actual'], label='Actual', color='blue')\nplt.plot(test_df['time'], test_df['Predicted'], label='Predicted', color='red', linestyle='--')\nplt.xlabel('Time')\nplt.ylabel('Bloom Status')\nplt.legend()\nplt.tight_layout()\n\n# Save updated figure\nplt.savefig(os.path.join(output_dir, 'actual_predicted_SWFL_Tampa.png'), dpi=300, bbox_inches='tight')\nplt.show()\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-2-5-actual-vs-predicted-bloom","position":37},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.6 Learning Curve","lvl2":"2. ML Evaluation"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-2-6-learning-curve","position":38},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.6 Learning Curve","lvl2":"2. ML Evaluation"},"content":"\n\nThe learning curve below illustrates the model’s performance as the training set size increases. It plots training accuracy (blue) and validation accuracy (orange) to help assess model generalization and overfitting behavior.\n\nTraining Score (Blue Line at 1.00):The model achieves perfect accuracy on the training set across all sample sizes, indicating potential overfitting. This suggests the model memorizes the training data exceptionally well.\n\nValidation Score (Orange Line):Validation accuracy begins around 0.72 and steadily increases, plateauing around 0.84. This trend shows that the model generalizes better as more data becomes available and benefits from a larger training set.\n\nGap Between Training and Validation:The persistent gap between the training and validation scores highlights a generalization gap. The model performs very well on seen data but does not achieve the same level of accuracy on unseen data.\n\nInterpretation\n\nThe Random Forest model shows strong memorization capability but limited generalization, suggesting high model capacity.\n\nThe plateau in validation performance (~84%) implies the model has learned most of the signal available in the data.\n\nThis learning curve confirms that while the model is accurate and stable, further refinements may enhance its robustness in operational bloom forecasting.\n\nfrom sklearn.model_selection import learning_curve\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n# Create output directory if it doesn't exist\noutput_dir = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Final_Graphics\"\nos.makedirs(output_dir, exist_ok=True)\n\n# Generate Learning Curve data\ntrain_sizes, train_scores, test_scores = learning_curve(\n    rf_clf,\n    X_train_scaled,\n    y_train,\n    cv=5,\n    scoring='accuracy',\n    n_jobs=-1,\n    train_sizes=np.linspace(0.1, 1.0, 10)\n)\n\n# Compute mean scores across folds\ntrain_mean = train_scores.mean(axis=1)\ntest_mean = test_scores.mean(axis=1)\n\n# Plot Learning Curve\nplt.figure(figsize=(8, 6))\nplt.plot(train_sizes, train_mean, label='Training Score', color='blue')\nplt.plot(train_sizes, test_mean, label='Validation Score', color='orange')\nplt.xlabel('Training Set Size')\nplt.ylabel('Accuracy')\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\nplt.savefig(os.path.join(output_dir, 'learning_curve_SWFL_Tampa.png'), dpi=300, bbox_inches='tight')\nplt.show()\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-2-6-learning-curve","position":39},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.7 Pair Plot","lvl2":"2. ML Evaluation"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-2-7-pair-plot","position":40},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"2.7 Pair Plot","lvl2":"2. ML Evaluation"},"content":"\n\nThe pair plot below displays the relationships and distributions among Karenia brevis cell concentrations (kb), river discharge, and nutrient levels from both the Peace and Caloosahatchee Rivers using the updated dataset that includes Tampa KB data.\n\nAll nutrient and discharge variables continue to exhibit strong right-skewed distributions, with most values clustered at the low end and occasional extreme values. This reflects episodic nutrient surges and discharge events, which are typical of coastal watershed systems.\n\nWhile linear correlations between kb and other variables remain weak, the plot reveals key clustering patterns — particularly, higher kb values tend to coincide with moderate levels of river discharge (peace_discharge, caloosa_discharge) and elevated nutrient concentrations (peace_TN, caloosa_total_nitrogen), suggesting bloom activity may be triggered or sustained by these conditions.\n\nNutrient distributions remain consistent between the two rivers, and both nitrogen and phosphorus variables show wide variability, reinforcing their role as co-drivers of bloom events. Notably, the inclusion of Tampa KB data does not introduce conflicting trends, indicating the broader regional coherence of bloom-nutrient-discharge relationships.\n\nThese patterns suggest that Karenia brevis bloom dynamics are governed by nonlinear, episodic processes involving both nutrient inputs and hydrological forcing from multiple rivers. The Tampa KB data strengthens the ecological signal, supporting the idea that spatially aggregated bloom data can still yield consistent and informative predictors of bloom risk.\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport os\nimport pandas as pd\n\n# Load the merged SWFL + Tampa KB dataset\ndf_swfl_merged = pd.read_csv(\"swfl_merged_features_tampa.csv\")\n\n# Ensure figures folder exists\nos.makedirs(\"Figures\", exist_ok=True)\n\n# Select relevant variables for pair plot\npairplot_vars = [\n    'kb', 'peace_discharge', 'peace_TN', 'peace_TP',\n    'caloosa_discharge', 'caloosa_total_nitrogen', 'caloosa_total_phosphorus'\n]\n\n# Generate pair plot\nsns.pairplot(df_swfl_merged[pairplot_vars], diag_kind='kde')\nplt.savefig(\"Figures/pair_plot_SWFL_Tampa.png\", dpi=300, bbox_inches='tight')\nplt.show()\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-2-7-pair-plot","position":41},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"3. XGBoost Model"},"type":"lvl2","url":"/ml-model-swfl-with-tampa#id-3-xgboost-model","position":42},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"3. XGBoost Model"},"content":"\n\nWe implemented XGBoost (Extreme Gradient Boosting) as an alternative machine learning model to predict harmful algal bloom (HAB) events one week in advance. XGBoost is a high-performance, tree-based algorithm known for its ability to model complex, nonlinear relationships in structured tabular data. It builds decision trees sequentially, with each new tree correcting the errors of the previous one — making it particularly effective for classification tasks.\n\nWe selected XGBoost because:\n\nIt handles imbalanced datasets well using the scale_pos_weight parameter.\n\nIt often outperforms traditional methods like Random Forest in predictive accuracy when properly tuned.\n\nIt allows for fine-grained control over learning behavior and regularization to reduce overfitting.\n\n# Import necessary libraries\nfrom xgboost import XGBClassifier\nfrom sklearn.metrics import classification_report, confusion_matrix, balanced_accuracy_score\nfrom sklearn.model_selection import train_test_split\n\n# Define feature columns and target\nfeatures = [\n    'kb', 'kb_prev1', 'kb_prev2',\n    'zos', 'salinity', 'water_temp',\n    'wind_speed', 'wind_direction',\n    'peace_discharge', 'peace_TN', 'peace_TP',\n    'peace_discharge_prev1', 'peace_TN_prev1', 'peace_TP_prev1',\n    'caloosa_discharge', 'caloosa_total_nitrogen', 'caloosa_total_phosphorus',\n    'caloosa_discharge_prev1', 'caloosa_TN_prev1', 'caloosa_TP_prev1',\n    'discharge_4w_avg'\n]\n\ntarget = 'target_next_week'\n\n# Split into train and test\nX = df[features]\ny = df[target]\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=y, random_state=42)\n\n# Compute class weight ratio\nclass_weight_ratio = y_train.value_counts()[0] / y_train.value_counts()[1]\n\n# Initialize and fit XGBoost model\nxgb_model = XGBClassifier(\n    scale_pos_weight=class_weight_ratio,  # handle imbalance\n    n_estimators=100,\n    learning_rate=0.1,\n    max_depth=4,\n    use_label_encoder=False,\n    eval_metric='logloss',\n    random_state=42\n)\n\nxgb_model.fit(X_train, y_train)\n\n# Predict and evaluate\ny_pred = xgb_model.predict(X_test)\n\nprint(\"Balanced Accuracy:\", balanced_accuracy_score(y_test, y_pred))\nprint(\"Confusion Matrix:\\n\", confusion_matrix(y_test, y_pred))\nprint(\"Classification Report:\\n\", classification_report(y_test, y_pred, target_names=[\"No Bloom\", \"Bloom\"]))\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-3-xgboost-model","position":43},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"XGBoost Model Performance Summary","lvl2":"3. XGBoost Model"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#xgboost-model-performance-summary","position":44},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"XGBoost Model Performance Summary","lvl2":"3. XGBoost Model"},"content":"The XGBoost classifier demonstrated solid performance in predicting Karenia brevis bloom events one week in advance using the Southwest Florida (SWFL) dataset with the inclusion of Tampa KB data. The model achieved an overall accuracy of 84% and a balanced accuracy of 81.0%, indicating good predictive capability across both bloom and non-bloom classes.","type":"content","url":"/ml-model-swfl-with-tampa#xgboost-model-performance-summary","position":45},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl4":"Class-Specific Performance:","lvl3":"XGBoost Model Performance Summary","lvl2":"3. XGBoost Model"},"type":"lvl4","url":"/ml-model-swfl-with-tampa#class-specific-performance","position":46},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl4":"Class-Specific Performance:","lvl3":"XGBoost Model Performance Summary","lvl2":"3. XGBoost Model"},"content":"No Bloom:\n\nPrecision: 0.90\n\nRecall: 0.87\n\nF1-score: 0.88\n\nSupport: 231 samples\n\nBloom:\n\nPrecision: 0.70\n\nRecall: 0.75\n\nF1-score: 0.72\n\nSupport: 92 samples\n\nThe classifier continues to perform well for no-bloom predictions, with high precision and recall. For bloom predictions, the model captures 75% of true bloom events, a slight drop from the Random Forest baseline but still effective for early-warning applications. The precision of 0.70 suggests moderate false positives, which may be acceptable depending on monitoring priorities.","type":"content","url":"/ml-model-swfl-with-tampa#class-specific-performance","position":47},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl4":"Overall Averages:","lvl3":"XGBoost Model Performance Summary","lvl2":"3. XGBoost Model"},"type":"lvl4","url":"/ml-model-swfl-with-tampa#overall-averages","position":48},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl4":"Overall Averages:","lvl3":"XGBoost Model Performance Summary","lvl2":"3. XGBoost Model"},"content":"Macro average F1-score: 0.80\n\nWeighted average F1-score: 0.84","type":"content","url":"/ml-model-swfl-with-tampa#overall-averages","position":49},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl4":"Confusion Matrix Summary:","lvl3":"XGBoost Model Performance Summary","lvl2":"3. XGBoost Model"},"type":"lvl4","url":"/ml-model-swfl-with-tampa#confusion-matrix-summary","position":50},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl4":"Confusion Matrix Summary:","lvl3":"XGBoost Model Performance Summary","lvl2":"3. XGBoost Model"},"content":"\n\nPredicted No Bloom\n\nPredicted Bloom\n\nActual No Bloom\n\n201\n\n30\n\nActual Bloom\n\n23\n\n69\n\nThese results suggest that the XGBoost model effectively captures bloom dynamics and offers a reasonable trade-off between recall and precision, even without fine-tuned hyperparameters. Although it slightly underperforms compared to the best-performing Random Forest configuration, it remains a reliable and interpretable model. With further tuning, XGBoost could become a strong operational forecasting tool for Karenia brevis blooms in Southwest Florida.\n\n","type":"content","url":"/ml-model-swfl-with-tampa#confusion-matrix-summary","position":51},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"3.1 Quick Hyperparameter Tuning with RandomizedSearchCV","lvl2":"3. XGBoost Model"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-3-1-quick-hyperparameter-tuning-with-randomizedsearchcv","position":52},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"3.1 Quick Hyperparameter Tuning with RandomizedSearchCV","lvl2":"3. XGBoost Model"},"content":"\n\nTo improve the performance of the XGBoost model, we performed a quick hyperparameter tuning using RandomizedSearchCV. This approach samples a subset of possible parameter combinations rather than evaluating all combinations exhaustively. We used 20 random trials and 3-fold cross-validation to identify a better-performing configuration.\n\nThe hyperparameters tested included tree depth, learning rate, number of estimators, and subsampling ratios. We maintained class imbalance handling by preserving the scale_pos_weight. The optimized model was then evaluated on the test set to assess whether it improved bloom prediction performance over the original configuration.\n\nfrom sklearn.model_selection import RandomizedSearchCV\nfrom scipy.stats import randint, uniform\nimport numpy as np\n\n# Define parameter distribution\nparam_dist = {\n    'n_estimators': randint(50, 200),\n    'max_depth': randint(3, 10),\n    'learning_rate': uniform(0.01, 0.2),\n    'subsample': uniform(0.6, 0.4),\n    'colsample_bytree': uniform(0.6, 0.4),\n    'scale_pos_weight': [class_weight_ratio],  # already computed earlier\n}\n\n# Initialize base model\nxgb_base = XGBClassifier(\n    use_label_encoder=False,\n    eval_metric='logloss',\n    random_state=42\n)\n\n# Run randomized search (20 trials, 3-fold CV)\nrandom_search = RandomizedSearchCV(\n    estimator=xgb_base,\n    param_distributions=param_dist,\n    n_iter=20,\n    scoring='f1',\n    cv=3,\n    verbose=1,\n    random_state=42,\n    n_jobs=-1\n)\n\nrandom_search.fit(X_train, y_train)\n\n# Evaluate best model\nbest_xgb = random_search.best_estimator_\ny_pred_best = best_xgb.predict(X_test)\n\n# Output results\nprint(\"Best Parameters:\", random_search.best_params_)\nprint(\"Balanced Accuracy:\", balanced_accuracy_score(y_test, y_pred_best))\nprint(\"Confusion Matrix:\\n\", confusion_matrix(y_test, y_pred_best))\nprint(\"Classification Report:\\n\", classification_report(\n    y_test, y_pred_best, target_names=[\"No Bloom\", \"Bloom\"]))\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-3-1-quick-hyperparameter-tuning-with-randomizedsearchcv","position":53},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"3.2 Summary XGBoost Before and After Hyperparameter Tuning","lvl2":"3. XGBoost Model"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-3-2-summary-xgboost-before-and-after-hyperparameter-tuning","position":54},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"3.2 Summary XGBoost Before and After Hyperparameter Tuning","lvl2":"3. XGBoost Model"},"content":"\n\nWe evaluated the performance of the default XGBoost model against a tuned version using RandomizedSearchCV. The tuned model yielded modest but meaningful improvements, particularly in detecting harmful algal blooms (the minority class).\n\nBest Parameters Selected:\n\nn_estimators: 89\n\nmax_depth: 3\n\nlearning_rate: 0.04\n\nsubsample: 0.94\n\ncolsample_bytree: 0.63\n\nscale_pos_weight: 2.52\n\nKey Improvements:\n\nBalanced Accuracy increased from 0.810 to 0.824\n\nBloom Recall improved from 0.75 to 0.78, meaning more actual blooms were correctly detected\n\nBloom F1-score rose from 0.72 to 0.74, indicating a better balance between sensitivity and precision\n\nFalse negatives (missed blooms) decreased from 23 to 20\n\nTrade-offs:\n\nThe number of false positives (non-blooms predicted as blooms) increased slightly (from 30 to 31), but this is considered acceptable in the context of early-warning systems where missing a bloom is more detrimental than a false alert.\n\nConclusion:\nHyperparameter tuning led to a slightly more balanced and sensitive XGBoost model for forecasting Karenia brevis bloom events. These adjustments improve early detection performance while maintaining overall robustness.\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-3-2-summary-xgboost-before-and-after-hyperparameter-tuning","position":55},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"3.3 Summary Tuned XGBoost vs. Random Forest","lvl2":"3. XGBoost Model"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-3-3-summary-tuned-xgboost-vs-random-forest","position":56},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"3.3 Summary Tuned XGBoost vs. Random Forest","lvl2":"3. XGBoost Model"},"content":"\n\nWe compared the performance of the tuned XGBoost model to the Random Forest model in predicting Karenia brevis bloom events one week ahead. The results show that Random Forest clearly outperformed the tuned XGBoost model across most metrics, although XGBoost maintained a marginal advantage in reducing false negatives.\n\nPerformance Summary:\n\nAccuracy: Random Forest = 0.90, Tuned XGBoost = 0.86\n\nBalanced Accuracy: Random Forest = 0.855, Tuned XGBoost = 0.824\n\nBloom Precision: Random Forest = 0.90, Tuned XGBoost = 0.70\n\nBloom Recall: Random Forest = 0.79, Tuned XGBoost = 0.78\n\nBloom F1-score: Random Forest = 0.85, Tuned XGBoost = 0.74\n\nFalse Negatives (missed blooms): Tuned XGBoost = 20, Random Forest = 18\n\nFalse Positives: Tuned XGBoost = 31, Random Forest = 7\n\nConclusion:\n\nThe Random Forest model provided better overall performance, with higher precision, accuracy, and fewer false positives. This makes it a strong candidate for operational forecasting where minimizing false alerts is critical.\n\nThe Tuned XGBoost model, while slightly behind in most metrics, offered comparable recall to Random Forest and remains a useful option when seeking to diversify model perspectives or explore ensemble approaches.\n\nIn this comparison, Random Forest demonstrated a more favorable balance between sensitivity and specificity. However, model selection ultimately depends on the operational objective—whether it’s more important to minimize missed bloom events (recall) or to reduce false bloom predictions (precision).\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define metrics and scores\nmetrics = ['Accuracy', 'Balanced Accuracy', 'Bloom Precision', 'Bloom Recall', 'Bloom F1-score']\nrf_scores = [0.90, 0.875, 0.88, 0.80, 0.84]       # Best RF model (with Tampa KB)\nxgb_scores = [0.86, 0.824, 0.70, 0.78, 0.74]       # Tuned XGB model (with Tampa KB)\n\nx = np.arange(len(metrics))\nwidth = 0.35\n\nplt.figure(figsize=(10, 6))\nbars_rf = plt.bar(x - width/2, rf_scores, width, label='Random Forest')\nbars_xgb = plt.bar(x + width/2, xgb_scores, width, label='Tuned XGBoost')\n\n# Add value labels\nfor bar in bars_rf:\n    height = bar.get_height()\n    plt.text(bar.get_x() + bar.get_width()/2, height + 0.015, f\"{height:.2f}\", ha='center', va='bottom')\n\nfor bar in bars_xgb:\n    height = bar.get_height()\n    plt.text(bar.get_x() + bar.get_width()/2, height + 0.015, f\"{height:.2f}\", ha='center', va='bottom')\n\nplt.ylabel('Score')\nplt.xticks(x, metrics, rotation=45)\nplt.ylim(0.6, 1.05)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-3-3-summary-tuned-xgboost-vs-random-forest","position":57},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"4. Support Vector Classifier (Linear Kernel)"},"type":"lvl2","url":"/ml-model-swfl-with-tampa#id-4-support-vector-classifier-linear-kernel","position":58},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"4. Support Vector Classifier (Linear Kernel)"},"content":"\n\nWe implemented a Support Vector Classifier (SVC) with a linear kernel to serve as a strong linear baseline model for predicting harmful algal blooms. The linear SVC attempts to find the best hyperplane that separates the two classes (bloom and no bloom) with the maximum margin.\n\nThis model is particularly useful because:\n\nIt performs well on moderately sized datasets.\n\nIt provides a clear, interpretable decision boundary.\n\nIt allows direct inspection of feature weights (similar to logistic regression).\n\nIt is less prone to overfitting than more flexible nonlinear models when the data is approximately linearly separable.\n\nWe used class_weight='balanced' to account for class imbalance and evaluated the model using balanced accuracy and F1-score, with special attention to performance on the bloom class. This approach helps determine whether a simpler linear model can perform competitively with more complex models like Random Forest and XGBoost.\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-4-support-vector-classifier-linear-kernel","position":59},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"4.1 Re-Split and Scaled the Data","lvl2":"4. Support Vector Classifier (Linear Kernel)"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-4-1-re-split-and-scaled-the-data","position":60},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"4.1 Re-Split and Scaled the Data","lvl2":"4. Support Vector Classifier (Linear Kernel)"},"content":"\n\nWe re-split the data using train_test_split to ensure that the input features (X) and target labels (y) have matching sample sizes. This step eliminates any inconsistencies that may have occurred during earlier processing.\n\nWe also applied StandardScaler to normalize the feature values, which is important for models like Support Vector Machines that are sensitive to the scale of input data. Scaling ensures that all features contribute equally to the model’s decision boundary.\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\n\n# Re-split data cleanly to ensure matching sizes\nX = df[features]\ny = df['target_next_week']\n\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, stratify=y, random_state=42\n)\n\n# Scale features\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n\n\n\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import classification_report, balanced_accuracy_score\n\nsvc_linear = SVC(kernel='linear', class_weight='balanced', random_state=42)\nsvc_linear.fit(X_train_scaled, y_train)\n\ny_pred_svc = svc_linear.predict(X_test_scaled)\n\nprint(\"Balanced Accuracy:\", balanced_accuracy_score(y_test, y_pred_svc))\nprint(\"Classification Report:\\n\", classification_report(y_test, y_pred_svc, target_names=[\"No Bloom\", \"Bloom\"]))\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-4-1-re-split-and-scaled-the-data","position":61},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"4.2 Summary of Support Vector Classifier (Linear Kernel)","lvl2":"4. Support Vector Classifier (Linear Kernel)"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-4-2-summary-of-support-vector-classifier-linear-kernel","position":62},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"4.2 Summary of Support Vector Classifier (Linear Kernel)","lvl2":"4. Support Vector Classifier (Linear Kernel)"},"content":"\n\nThe Support Vector Classifier (SVC) with a linear kernel achieved an overall accuracy of 0.83 and a balanced accuracy of 0.74 on the full SWFL dataset including Tampa Karenia brevis data. While the model performs well at identifying non-bloom cases, it continues to struggle with reliably detecting bloom events.\n\nClass-wise performance:\n\nNo Bloom (class 0):\n\nPrecision: 0.84\n\nRecall: 0.94\n\nF1-score: 0.89\n\nInterpretation: The model is highly effective at detecting non-bloom conditions.\n\nBloom (class 1):\n\nPrecision: 0.79\n\nRecall: 0.54\n\nF1-score: 0.65\n\nInterpretation: The model is moderately precise when predicting a bloom, but still misses nearly half of actual bloom events.\n\nSummary:\n\nOverall, the linear SVC model remains a more conservative classifier. It favors predicting “No Bloom” and only predicts “Bloom” when it is relatively confident. This approach results in relatively few false positives (false bloom alerts) but a higher number of false negatives (missed bloom events). While this behavior may be acceptable in settings where false alarms must be minimized, it may be unsuitable in environmental or public health contexts where early detection of harmful blooms is a priority.\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-4-2-summary-of-support-vector-classifier-linear-kernel","position":63},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"5. Model Comparison"},"type":"lvl2","url":"/ml-model-swfl-with-tampa#id-5-model-comparison","position":64},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"5. Model Comparison"},"content":"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the performance metrics\nmetrics = ['Accuracy', 'Balanced Accuracy', 'Bloom Precision', 'Bloom Recall', 'Bloom F1-score']\n\n# Updated scores for the most recent SWFL + Tampa KB run\nrf_scores =  [0.90, 0.875, 0.88, 0.80, 0.84]  # from previous RF evaluation\nxgb_scores = [0.86, 0.857, 0.81, 0.78, 0.77]  # tuned XGBoost on new dataset\nsvc_scores = [0.83, 0.743, 0.79, 0.54, 0.65]  # new SVC results from latest output\n\n# Set up bar positions\nx = np.arange(len(metrics))\nwidth = 0.25  # Width of each bar\n\n# Create the plot\nplt.figure(figsize=(10, 7))\nbars_rf = plt.bar(x - width, rf_scores, width, label='Random Forest')\nbars_xgb = plt.bar(x, xgb_scores, width, label='Tuned XGBoost')\nbars_svc = plt.bar(x + width, svc_scores, width, label='Linear SVC')\n\n# Add value labels above each bar\nfor bars in [bars_rf, bars_xgb, bars_svc]:\n    for bar in bars:\n        height = bar.get_height()\n        plt.text(bar.get_x() + bar.get_width() / 2, height + 0.01, f\"{height:.2f}\",\n                 ha='center', va='bottom')\n\n# Customize chart appearance\nplt.ylabel('Score')\nplt.xticks(x, metrics, rotation=45)\nplt.ylim(0.5, 1.0)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-5-model-comparison","position":65},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"5.1 Summary of Model Performance Comparison","lvl2":"5. Model Comparison"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-5-1-summary-of-model-performance-comparison","position":66},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"5.1 Summary of Model Performance Comparison","lvl2":"5. Model Comparison"},"content":"\n\nThe bar chart compares the performance of three classification models: Random Forest, Tuned XGBoost, and Linear SVC. Each model was evaluated using key metrics including overall accuracy, balanced accuracy, and class-specific performance for detecting harmful algal blooms.\n\nKey Insights:\n\nRandom Forest delivers the strongest overall performance:\n\nAccuracy: 0.90\n\nBalanced Accuracy: 0.88\n\nBloom Precision: 0.88\n\nBloom Recall: 0.80\n\nBloom F1-score: 0.84\n\nConclusion: This model balances bloom detection and false positive avoidance, making it a reliable choice for operational deployment.\n\nTuned XGBoost offers competitive performance:\n\nAccuracy: 0.86\n\nBalanced Accuracy: 0.86\n\nBloom Precision: 0.81\n\nBloom Recall: 0.85\n\nBloom F1-score: 0.77\n\nConclusion: This model sacrifices some precision in order to catch more actual bloom events, making it ideal where early detection is a priority despite a slightly higher false alarm rate.\n\nLinear SVC underperforms in bloom detection:\n\nAccuracy: 0.85\n\nBalanced Accuracy: 0.75\n\nBloom Precision: 0.79\n\nBloom Recall: 0.54\n\nBloom F1-score: 0.65\n\nConclusion: While this model avoids false positives, its lower recall leads to more missed bloom events, limiting its value for sensitive ecological monitoring.\n\nConclusion:\n\nRandom Forest remains the top-performing model with the best all-around accuracy, balance, and bloom detection reliability.\n\nTuned XGBoost is preferred when early bloom detection is critical, especially in high-risk conditions.\n\nLinear SVC may be suitable for exploratory or low-risk use cases, but its low sensitivity makes it less viable for real-time or mission-critical bloom monitoring.\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-5-1-summary-of-model-performance-comparison","position":67},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"6. KB Probability as a Function of TN and TP"},"type":"lvl2","url":"/ml-model-swfl-with-tampa#id-6-kb-probability-as-a-function-of-tn-and-tp","position":68},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl2":"6. KB Probability as a Function of TN and TP"},"content":"\n\nThis plot was created using a Random Forest classifier trained to predict the likelihood of a KB bloom event based on combined nutrient concentrations from the Peace and Caloosahatchee Rivers. Specifically, TN was calculated as the sum of peace_TN and caloosa_total_nitrogen, and TP as the sum of peace_TP and caloosa_total_phosphorus. The model was trained on historical data from the merged SWFL + Tampa KB dataset. After training, bloom probabilities were predicted across a meshgrid of TN and TP values spanning the 1st to 99th percentiles of observed concentrations. These predictions were smoothed using a Gaussian filter to reduce noise and enhance interpretability. The result is a continuous contour map showing bloom probability as a function of nutrient levels, with a red gradient indicating increasing bloom risk.\n\nfrom sklearn.ensemble import RandomForestClassifier\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load your merged dataset (make sure this path matches your actual CSV)\ndf = pd.read_csv('swfl_merged_features_tampa.csv', parse_dates=['time'])\n\n# Filter out rows with missing data for all required columns\ndf = df[['peace_TN', 'peace_TP', 'caloosa_total_nitrogen', 'caloosa_total_phosphorus', 'kb']].dropna()\n\n# Create binary target: bloom if kb >= 100000\ndf['bloom'] = (df['kb'] >= 100000).astype(int)\n\n# Define combined TN and TP using intermediate variables (does NOT overwrite columns)\ntotal_TN = df['peace_TN'] + df['caloosa_total_nitrogen']\ntotal_TP = df['peace_TP'] + df['caloosa_total_phosphorus']\n\n# Train classifier using combined TN and TP\nX = pd.DataFrame({'total_TN': total_TN, 'total_TP': total_TP})\ny = df['bloom']\n\nclf = RandomForestClassifier(n_estimators=100, class_weight='balanced', random_state=42)\nclf.fit(X, y)\n\n# Create grid\ntn_vals = np.linspace(total_TN.quantile(0.01), total_TN.quantile(0.99), 100)\ntp_vals = np.linspace(total_TP.quantile(0.01), total_TP.quantile(0.99), 100)\nTN, TP = np.meshgrid(tn_vals, tp_vals)\n\n# Predict bloom probability over grid\nbloom_probs = np.zeros_like(TN)\n\nfor i in range(TN.shape[0]):\n    for j in range(TN.shape[1]):\n        sample = pd.DataFrame({'total_TN': [TN[i, j]], 'total_TP': [TP[i, j]]})\n        bloom_probs[i, j] = clf.predict_proba(sample)[0, 1]\n\n# Plot\nplt.figure(figsize=(10, 6))\ncontour = plt.contourf(TN, TP, bloom_probs, levels=20, cmap='Reds')\ncbar = plt.colorbar(contour)\ncbar.set_label('Bloom Probability')\nplt.xlabel('Total Nitrogen (mg/L)')\nplt.ylabel('Total Phosphorus (mg/L)')\nplt.show()\n\n\n\n\n\n","type":"content","url":"/ml-model-swfl-with-tampa#id-6-kb-probability-as-a-function-of-tn-and-tp","position":69},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"6.1 Conclusion","lvl2":"6. KB Probability as a Function of TN and TP"},"type":"lvl3","url":"/ml-model-swfl-with-tampa#id-6-1-conclusion","position":70},{"hierarchy":{"lvl1":"Machine Learning Model for Combined Peace River and Caloosahatchee River","lvl3":"6.1 Conclusion","lvl2":"6. KB Probability as a Function of TN and TP"},"content":"\n\nKey Insights\n\nThe contour plot reveals that KB bloom risk is strongly associated with elevated nutrient concentrations, particularly total phosphorus. Bloom probabilities increase markedly when TP exceeds ~1.5–2.5 mg/L, especially when total nitrogen is also elevated. The highest predicted bloom probabilities occur when both TN and TP are simultaneously high, suggesting that bloom formation is influenced by co-limitation or synergistic effects between the two nutrients. Conversely, low concentrations of either nutrient suppress bloom probability, reinforcing the ecological expectation that both nitrogen and phosphorus must be sufficiently available to support bloom development.\n\nReal-World Implications\n\nThese results emphasize the importance of joint nutrient management across both the Peace and Caloosahatchee River systems. Because bloom risk is driven by combined nutrient input, mitigating only one nutrient source or one watershed may not be sufficient. Watershed planners and environmental managers can use this plot to identify nutrient concentration zones most associated with bloom risk and prioritize efforts to reduce both nitrogen and phosphorus loading. Additionally, this model could support early warning systems by identifying high-risk nutrient conditions in real time, providing a data-driven foundation for forecasting and mitigation strategies.","type":"content","url":"/ml-model-swfl-with-tampa#id-6-1-conclusion","position":71},{"hierarchy":{"lvl1":"Watershed Study Area"},"type":"lvl1","url":"/watershed-graphics","position":0},{"hierarchy":{"lvl1":"Watershed Study Area"},"content":"","type":"content","url":"/watershed-graphics","position":1},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"1. Caloosahatchee Watershed Boundary Extraction"},"type":"lvl2","url":"/watershed-graphics#id-1-caloosahatchee-watershed-boundary-extraction","position":2},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"1. Caloosahatchee Watershed Boundary Extraction"},"content":"\n\nThe Caloosahatchee River watershed boundary was obtained from the USGS Watershed Boundary Dataset (WBD) by querying the hydrologic unit corresponding to HUC-8 03090205. The resulting polygon defines the official extent of the Caloosahatchee basin and serves as the spatial framework for subsequent mapping and analysis.\n\nimport geopandas as gpd\n\nwbd_url = (\n    \"https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer/4/\"\n    \"query?where=HUC8%3D%2703090205%27&outFields=*&f=geojson\"\n)\n\ncaloosa = gpd.read_file(wbd_url)\n\nprint(caloosa.crs)   # just to see what it is\n\ncaloosa.plot(edgecolor=\"black\", facecolor=\"none\")\n\n\n\n\n\n\n\n","type":"content","url":"/watershed-graphics#id-1-caloosahatchee-watershed-boundary-extraction","position":3},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"2. Caloosahatchee River Flowline Extraction"},"type":"lvl2","url":"/watershed-graphics#id-2-caloosahatchee-river-flowline-extraction","position":4},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"2. Caloosahatchee River Flowline Extraction"},"content":"\n\nThe main stem of the Caloosahatchee River was extracted from the USGS National Hydrography Dataset (NHD) using a name-based query of the NHD Flowline (Large Scale) layer. All polyline features associated with the “Caloosahatchee” GNIS name were retrieved, providing an accurate representation of the river’s course through the watershed.\n\nimport geopandas as gpd\n\n# NHD Flowline - Large Scale (layer 6), search by name\nnhd_url = (\n    \"https://hydro.nationalmap.gov/arcgis/rest/services/nhd/MapServer/6/\"\n    \"query?where=gnis_name%20LIKE%20%27Caloosahatchee%25%27&outFields=*&f=geojson\"\n)\n\nriver = gpd.read_file(nhd_url)\n\nprint(\"River CRS:\", river.crs)\nprint(\"Number of features:\", len(river))\n\nif len(river) > 0:\n    ax = river.plot(color=\"deepskyblue\", linewidth=1)\nelse:\n    print(\"No features returned – name query didn't find anything.\")\n\n\n\n\n\npip install contextily\n\n\n\n","type":"content","url":"/watershed-graphics#id-2-caloosahatchee-river-flowline-extraction","position":5},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"3. Monitoring Stations, Coordinate Transformation, and Map Generation (Caloosahatchee)"},"type":"lvl2","url":"/watershed-graphics#id-3-monitoring-stations-coordinate-transformation-and-map-generation-caloosahatchee","position":6},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"3. Monitoring Stations, Coordinate Transformation, and Map Generation (Caloosahatchee)"},"content":"\n\nMonitoring station coordinates were compiled and converted into a geospatial dataset for inclusion on the study-area map. All spatial layers—including the watershed boundary, river flowline, and station locations—were reprojected to the Web Mercator coordinate system (EPSG:3857) to ensure compatibility with the OpenStreetMap basemap. These layers were then combined to generate a composite map of the Caloosahatchee watershed, providing a clear visualization of the basin, the river’s course, and the associated monitoring locations.\n\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Point\nimport contextily as cx\nimport matplotlib.lines as mlines\n\n# -----------------------------------------------------------\n# 1. STATION LOCATIONS (EDIT COORDS AS NEEDED)\n# -----------------------------------------------------------\nstations_data = [\n    {\"name\": \"S-79 NEAR OLGA\",        \"lon\": -81.7760, \"lat\": 26.7150},\n    {\"name\": \"CALOOSAHATCHEE BRIDGE\", \"lon\": -81.8780, \"lat\": 26.6400},\n    {\"name\": \"DEEP LAGOON\",           \"lon\": -81.9530, \"lat\": 26.5600},\n]\n\nstations = gpd.GeoDataFrame(\n    stations_data,\n    geometry=[Point(d[\"lon\"], d[\"lat\"]) for d in stations_data],\n    crs=\"EPSG:4326\"\n)\n\n# -----------------------------------------------------------\n# 2. PROJECT EVERYTHING TO WEB MERCATOR FOR BASEMAP\n# -----------------------------------------------------------\ntarget_crs = \"EPSG:3857\"\n\ncaloosa_3857 = caloosa.to_crs(target_crs)\nriver_3857   = river.to_crs(target_crs)\nstations_3857 = stations.to_crs(target_crs)\n\n# -----------------------------------------------------------\n# 3. START FIGURE\n# -----------------------------------------------------------\nfig, ax = plt.subplots(figsize=(4, 6), dpi=300)\n\n# Watershed outline\ncaloosa_3857.boundary.plot(ax=ax, color=\"black\", linewidth=1)\n\n# River line\nriver_3857.plot(ax=ax, color=\"deepskyblue\", linewidth=2)\n\n# Stations\nstations_3857.plot(ax=ax, color=\"blue\", markersize=25)\n\n# -----------------------------------------------------------\n# 4. PER-STATION LABEL OFFSETS (for cleaner labeling)\n# -----------------------------------------------------------\noffsets = {\n    \"S-79 NEAR OLGA\":        ( 2000,  700),\n    \"CALOOSAHATCHEE BRIDGE\": ( 2000,    0),\n    \"DEEP LAGOON\":           ( 2000, -800),\n}\n\nfor x, y, label in zip(\n        stations_3857.geometry.x,\n        stations_3857.geometry.y,\n        stations_3857[\"name\"]):\n    \n    dx, dy = offsets.get(label, (500, 500))\n    \n    ax.text(\n        x + dx,\n        y + dy,\n        label,\n        fontsize=6,\n        color=\"navy\",\n    )\n\n# -----------------------------------------------------------\n# 5. BASEMAP + EXTENT + LEGEND\n# -----------------------------------------------------------\nxmin, ymin, xmax, ymax = caloosa_3857.total_bounds\npad = 5000   # meters of padding around bounding box\n\nax.set_xlim(xmin - pad, xmax + pad)\nax.set_ylim(ymin - pad, ymax + pad)\n\n# Add OpenStreetMap basemap\ncx.add_basemap(\n    ax,\n    source=cx.providers.OpenStreetMap.Mapnik,\n    crs=target_crs,\n    alpha=0.8\n)\n\n# Legend handles\nstation_handle = mlines.Line2D(\n    [], [], color=\"blue\", marker=\"o\", linestyle=\"None\",\n    markersize=5, label=\"Stations\"\n)\nriver_handle = mlines.Line2D(\n    [], [], color=\"deepskyblue\", linewidth=2,\n    label=\"Caloosahatchee River\"\n)\n\nax.legend(handles=[station_handle, river_handle],\n          loc=\"upper right\", fontsize=7, frameon=True)\n\n# Remove axes ticks\nax.set_xticks([])\nax.set_yticks([])\n\nplt.tight_layout()\n\n# -----------------------------------------------------------\n# 6. SAVE HIGH-RES EXPORT\n# -----------------------------------------------------------\nplt.savefig(\"caloosahatchee_watershed_map.png\", dpi=600, bbox_inches=\"tight\")\nplt.savefig(\n    \"caloosahatchee_watershed_map.png\",\n    dpi=600,\n    bbox_inches=\"tight\"\n)\nplt.savefig(\n    r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Caloosahatchee watershed Graphics\\caloosahatchee_watershed_map.png\",\n    dpi=600,\n    bbox_inches=\"tight\"\n)\nplt.show()\n\n\n\n","type":"content","url":"/watershed-graphics#id-3-monitoring-stations-coordinate-transformation-and-map-generation-caloosahatchee","position":7},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"4. Peace River Watershed Boundary Extraction"},"type":"lvl2","url":"/watershed-graphics#id-4-peace-river-watershed-boundary-extraction","position":8},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"4. Peace River Watershed Boundary Extraction"},"content":"\n\nimport geopandas as gpd\n\n# Peace River HUC-8 from USGS WBD\nwbd_url_peace = (\n    \"https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer/4/\"\n    \"query?where=HUC8%3D%2703100101%27&outFields=*&f=geojson\"\n)\n\npeace_ws = gpd.read_file(wbd_url_peace)\n\nprint(peace_ws.crs)\npeace_ws.plot(edgecolor=\"black\", facecolor=\"none\")\n\n\n\n\n\n\n\n\n","type":"content","url":"/watershed-graphics#id-4-peace-river-watershed-boundary-extraction","position":9},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"5. Peace River Flowline From NHD"},"type":"lvl2","url":"/watershed-graphics#id-5-peace-river-flowline-from-nhd","position":10},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"5. Peace River Flowline From NHD"},"content":"\n\nimport geopandas as gpd\n\n# ---------------------------------------------------------------------\n# 1. Peace River watershed boundary (HUC-8: 03100101)\n# ---------------------------------------------------------------------\nwbd_url_peace = (\n    \"https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer/4/\"\n    \"query?where=HUC8%3D%2703100101%27&outFields=*&f=geojson\"\n)\n\npeace_ws = gpd.read_file(wbd_url_peace)\nprint(\"Peace WS CRS:\", peace_ws.crs)\n\n# ---------------------------------------------------------------------\n# 2. Peace River flowlines from NHD (often returns extra junk)\n# ---------------------------------------------------------------------\nnhd_url_peace = (\n    \"https://hydro.nationalmap.gov/arcgis/rest/services/nhd/MapServer/6/\"\n    \"query?where=gnis_name%20LIKE%20%27Peace%20River%25%27&outFields=*&f=geojson\"\n)\n\npeace_river = gpd.read_file(nhd_url_peace)\nprint(\"Raw flowline features:\", len(peace_river))\n\n# ---------------------------------------------------------------------\n# 3. Clip flowlines to the watershed to remove stray segments\n# ---------------------------------------------------------------------\n# Ensure CRS matches\npeace_ws = peace_ws.to_crs(peace_river.crs)\n\npeace_river_clip = gpd.overlay(peace_river, peace_ws, how=\"intersection\")\nprint(\"Clipped flowline features:\", len(peace_river_clip))\n\n# ---------------------------------------------------------------------\n# 4. Plot result\n# ---------------------------------------------------------------------\nax = peace_ws.plot(edgecolor=\"black\", facecolor=\"none\", figsize=(4, 6))\npeace_river_clip.plot(ax=ax, color=\"deepskyblue\", linewidth=1)\n\nplt.title(\"Peace River Flowline (Clipped to Watershed)\")\nplt.show()\n\n\n\n\n\n","type":"content","url":"/watershed-graphics#id-5-peace-river-flowline-from-nhd","position":11},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"6. Monitoring Stations, Coordinate Transformation, and Map Generation (Peace River)"},"type":"lvl2","url":"/watershed-graphics#id-6-monitoring-stations-coordinate-transformation-and-map-generation-peace-river","position":12},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"6. Monitoring Stations, Coordinate Transformation, and Map Generation (Peace River)"},"content":"\n\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Point\nimport contextily as cx\nimport matplotlib.lines as mlines\n\n# -----------------------------------------------------------\n# 1. PEACE RIVER STATION LOCATIONS (EDIT COORDS AS NEEDED)\n# -----------------------------------------------------------\nstations_peace_data = [\n    {\"name\": \"NEAR GARDNER\",          \"lon\": -81.8320229, \"lat\": 27.3669874},\n    {\"name\": \"ARCADIA\",               \"lon\": -81.8761946, \"lat\": 27.22088245},\n    {\"name\": \"NOCATEE\",               \"lon\": -81.90175090, \"lat\": 27.16282928},\n    {\"name\": \"PEACE RIVER RESERVOIR\", \"lon\": -82.056225, \"lat\": 27.056806},\n]\n\nstations_peace = gpd.GeoDataFrame(\n    stations_peace_data,\n    geometry=[Point(d[\"lon\"], d[\"lat\"]) for d in stations_peace_data],\n    crs=\"EPSG:4326\"\n)\n\n# -----------------------------------------------------------\n# 2. REPROJECT EVERYTHING TO WEB MERCATOR FOR BASEMAP\n# -----------------------------------------------------------\ntarget_crs = \"EPSG:3857\"\n\npeace_ws_3857       = peace_ws.to_crs(target_crs)\npeace_river_3857    = peace_river_clip.to_crs(target_crs)\nstations_peace_3857 = stations_peace.to_crs(target_crs)\n\n# -----------------------------------------------------------\n# 3. CREATE FIGURE (TALL LIKE YOUR ADVISOR'S)\n# -----------------------------------------------------------\nfig, ax = plt.subplots(figsize=(4, 8), dpi=300)\n\n# Watershed outline\npeace_ws_3857.boundary.plot(ax=ax, color=\"black\", linewidth=1)\n\n# River line\npeace_river_3857.plot(ax=ax, color=\"deepskyblue\", linewidth=2)\n\n# Stations\nstations_peace_3857.plot(ax=ax, color=\"blue\", markersize=25)\n\n# -----------------------------------------------------------\n# 4. LABELS WITH PER-STATION OFFSETS\n# -----------------------------------------------------------\noffsets_peace = {\n    \"NEAR GARDNER\":          ( 1500,  800),\n    \"ARCADIA\":               ( 1500,    0),\n    \"NOCATEE\":               ( 1500, -600),\n    \"PEACE RIVER RESERVOIR\": ( 1500, -800),\n}\n\nfor x, y, label in zip(\n        stations_peace_3857.geometry.x,\n        stations_peace_3857.geometry.y,\n        stations_peace_3857[\"name\"]):\n\n    dx, dy = offsets_peace.get(label, (500, 500))\n    ax.text(x + dx, y + dy, label, fontsize=6, color=\"navy\")\n\n# -----------------------------------------------------------\n# 5. EXTENT, BASEMAP, LEGEND\n# -----------------------------------------------------------\nxmin, ymin, xmax, ymax = peace_ws_3857.total_bounds\npad = 5000  # meters of padding\nax.set_xlim(xmin - pad, xmax + pad)\nax.set_ylim(ymin - pad, ymax + pad)\n\n# OSM basemap\ncx.add_basemap(\n    ax,\n    source=cx.providers.OpenStreetMap.Mapnik,\n    crs=target_crs,\n    alpha=0.8\n)\n\n# Legend entries\nstation_handle = mlines.Line2D([], [], color=\"blue\", marker=\"o\",\n                               linestyle=\"None\", markersize=5,\n                               label=\"Stations\")\nriver_handle = mlines.Line2D([], [], color=\"deepskyblue\",\n                             linewidth=2, label=\"Peace River\")\n\nax.legend(handles=[station_handle, river_handle],\n          loc=\"upper right\", fontsize=7, frameon=True)\n\nax.set_xticks([])\nax.set_yticks([])\n\nplt.tight_layout()\n\n# -----------------------------------------------------------\n# 6. SAVE HIGH-RES IMAGE TO YOUR FOLDER\n# -----------------------------------------------------------\nplt.savefig(\n    r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Peace River Watershed Graphics\\peace_river_watershed_map.png\",\n    dpi=600,\n    bbox_inches=\"tight\"\n)\n\nplt.show()\n\n\n\n","type":"content","url":"/watershed-graphics#id-6-monitoring-stations-coordinate-transformation-and-map-generation-peace-river","position":13},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"7. Generate Side by Side Graphic of Watersheds"},"type":"lvl2","url":"/watershed-graphics#id-7-generate-side-by-side-graphic-of-watersheds","position":14},{"hierarchy":{"lvl1":"Watershed Study Area","lvl2":"7. Generate Side by Side Graphic of Watersheds"},"content":"\n\nfrom PIL import Image\nimport matplotlib.pyplot as plt\n\n# --- EDIT THESE PATHS to your actual saved map files ---\npeace_png = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Peace River Watershed Graphics\\peace_river_watershed_map.png\"\ncaloosa_png = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Caloosahatchee watershed Graphics\\caloosahatchee_watershed_map.png\"\n\n# Output file\nout_png = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Figure_1_Study_Area_Peace_Caloosa.png\"\n\n# Load images\nimg_peace = Image.open(peace_png)\nimg_caloosa = Image.open(caloosa_png)\n\n# Make them the same height (keeps proportions clean)\ntarget_h = max(img_peace.height, img_caloosa.height)\n\nimg_peace = img_peace.resize(\n    (int(img_peace.width * target_h / img_peace.height), target_h)\n)\n\nimg_caloosa = img_caloosa.resize(\n    (int(img_caloosa.width * target_h / img_caloosa.height), target_h)\n)\n\n# Plot side-by-side\nfig, axes = plt.subplots(1, 2, figsize=(10, 7), dpi=300)\n\naxes[0].imshow(img_peace)\naxes[0].axis(\"off\")\naxes[0].text(\n    0.02, 0.98, \"(a)\",\n    transform=axes[0].transAxes,\n    ha=\"left\", va=\"top\",\n    fontsize=14,\n    bbox=dict(facecolor=\"white\", edgecolor=\"none\", alpha=0.75)\n)\n\naxes[1].imshow(img_caloosa)\naxes[1].axis(\"off\")\naxes[1].text(\n    0.02, 0.98, \"(b)\",\n    transform=axes[1].transAxes,\n    ha=\"left\", va=\"top\",\n    fontsize=14,\n    bbox=dict(facecolor=\"white\", edgecolor=\"none\", alpha=0.75)\n)\n\nplt.tight_layout()\n\n# Save combined figure\nplt.savefig(out_png, dpi=600, bbox_inches=\"tight\")\nplt.show()\n\n\n\nfrom PIL import Image, ImageOps\nimport matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\n\n# -----------------------------------------------------------\n# INPUT FILE PATHS (EDIT IF NEEDED)\n# -----------------------------------------------------------\npeace_png = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Peace River Watershed Graphics\\peace_river_watershed_map.png\"\ncaloosa_png = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Caloosahatchee watershed Graphics\\caloosahatchee_watershed_map.png\"\n\n# OUTPUT FILE\nout_png = r\"C:\\Users\\mkduu\\OneDrive\\Documents\\FGCU docs\\Summer 25 Red Tide Project\\Graphics\\Figure_1_Study_Area_Peace_Caloosa_PUBLICATION.png\"\n\n# -----------------------------------------------------------\n# LOAD IMAGES (CONVERT RGBA → RGB TO AVOID PIL ERROR)\n# -----------------------------------------------------------\nimgA = Image.open(peace_png).convert(\"RGB\")\nimgB = Image.open(caloosa_png).convert(\"RGB\")\n\n# OPTIONAL: autocontrast to tighten whites (safe now)\nimgA = ImageOps.autocontrast(imgA)\nimgB = ImageOps.autocontrast(imgB)\n\n# -----------------------------------------------------------\n# RESIZE TO MATCH WIDTHS (MAKES PANELS FEEL BALANCED)\n# -----------------------------------------------------------\ntarget_width = 1400  # adjust if desired\n\nimgA = imgA.resize(\n    (target_width, int(imgA.height * target_width / imgA.width))\n)\nimgB = imgB.resize(\n    (target_width, int(imgB.height * target_width / imgB.width))\n)\n\n# -----------------------------------------------------------\n# CREATE GRID LAYOUT (PUBLICATION STYLE)\n# -----------------------------------------------------------\nfig = plt.figure(figsize=(10, 7), dpi=300)\n\ngs = gridspec.GridSpec(\n    2, 2,\n    width_ratios=[1.0, 1.0],\n    height_ratios=[1.0, 1.0],\n    wspace=0.05,\n    hspace=0.05\n)\n\n# (a) Peace River — left column, full height\naxA = fig.add_subplot(gs[:, 0])\naxA.imshow(imgA)\naxA.axis(\"off\")\naxA.text(\n    0.02, 0.98, \"(a)\",\n    transform=axA.transAxes,\n    ha=\"left\", va=\"top\",\n    fontsize=14,\n    bbox=dict(facecolor=\"white\", edgecolor=\"none\", alpha=0.8)\n)\n\n# (b) Caloosahatchee — upper right\naxB = fig.add_subplot(gs[0, 1])\naxB.imshow(imgB)\naxB.axis(\"off\")\naxB.text(\n    0.02, 0.98, \"(b)\",\n    transform=axB.transAxes,\n    ha=\"left\", va=\"top\",\n    fontsize=14,\n    bbox=dict(facecolor=\"white\", edgecolor=\"none\", alpha=0.8)\n)\n\n# Bottom-right intentionally blank (clean composition)\nax_blank = fig.add_subplot(gs[1, 1])\nax_blank.axis(\"off\")\n\n# -----------------------------------------------------------\n# SAVE HIGH-RES FIGURE\n# -----------------------------------------------------------\nplt.savefig(out_png, dpi=600, bbox_inches=\"tight\")\nplt.show()\n\nprint(\"Saved publication figure to:\")\nprint(out_png)\n\n\n\n","type":"content","url":"/watershed-graphics#id-7-generate-side-by-side-graphic-of-watersheds","position":15},{"hierarchy":{"lvl1":"Red Tide Data and Modeling Book"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Red Tide Data and Modeling Book"},"content":"This Jupyter Book compiles the data processing, visualization, and machine learning analyses developed for the Southwest Florida red tide study.\n\nThe notebooks included here document:\n\nEnvironmental and hydrologic data integration for the Peace and Caloosahatchee River systems\n\nWatershed definitions and spatial context\n\nMachine learning–based prediction of Karenia brevis bloom occurrence, including the incorporation of Tampa Bay observations\n\nThis book is intended to provide a transparent, citable record of the analytical workflow supporting the associated journal manuscript.","type":"content","url":"/","position":1}]}